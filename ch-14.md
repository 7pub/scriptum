## Accumulating, Aggregating and Picking with Monoid

`Monoid` captures the notions of accumulating, aggregating and picking values, which all can be subsumed under the broader concept of combining. It lets us write code that is agnostic about the method we will actually use. Monoidal types are ubiquitous: `Sum`, `Product`, `List`, `Any`/`All`, `First`/`Last`, `Min`/`Max`, predicates, comparison, equivalence etc.

### Appending with identity

The `Monoid` type class comprises two properties:

```javascript
const append = x => y => ???
const empty = ???;
```
The associative `append` function takes two values of the same type and returns a combined value of this type. Appending as a term is a bit too narrow to cover the concept. For that reason you should consider `append` rather metaphorically. `empty` is an identity element, i.e. a neutral element that have no effect when applied to `append` and thus leaves the other value unchanged. Let us fill the gaps with an example:

```javascript
const sumAppend = x => y => x + y
const sumEmpty = () => 0;

sumAppend(10) (sumEmpty()); // 10

const prodAppend = x => y => x * y
const prodEmpty = () => 1;

prodAppend(10) (sumEmpty()); // 10
```
`append` is more or less self-explanatory. `empty` should also be clear now: `0 + 1 === 1` and `1 * 1 === 1` both do not affect the result of the operatons. The underlying type of both addition and multiplication are the natural numbers, that is, a single type can have more than one useful monoidal structures. We used the simple `Sum` and `Product` type wrappers to distinguish their instances. Please note that both types represent the accumulating notion of monoidal computations.

Strictly speaking only `empty` is a direct part of the `Monoid` type class, whereas `append` is inherited by the `Semigroup` superclass. Both type classes complement each other and are so closely connected that we often just talk about monoid though. There are some types that only have a `Semigroup` instance, but we will learn in a later section of this chapter how to lift every semigroup into a monoid.

#### Associativity

I have already mentioned that `append` must be associative in order to guarantee the following property:

```javascript
const sumAppend = x => y => x + y
const diffAppend = x => y => x - y

// associative

sumAppend(sumAppend(2) (5)) (10) === sumAppend(2) (sumAppend(5) (10));

// non-associative

diffAppend(diffAppend(2) (5)) (10) !== diffAppend(2) (diffAppend(5) (10));
```
Given the example above we can derive that there is a monoid under addition but none under subtraction.

### Type level

On the type level a monoid is just a first order type constructor, because in contrast to functor monoid does not distinguish between value and context. A value is just a value without any additional semantics:

```javascript
type append<A> = (_: A) => (_: A) => A;
type empty<A> = () => A;
```
### The `Array` instance

Arrays in terms of monoids are pretty much self-explanatory:

```javascript
const arrAppend = xs => ys =>
  (xs.push.apply(xs, ys), xs);

const arrPrepend = ys => xs =>
  (xs.push.apply(xs, ys), xs);

const arrEmpty = () => [];

arrAppend([1, 2, 3]) ([4, 5, 6]); // [1, 2, 3, 4, 5, 6]

arrPrepend([1, 2, 3]) ([4, 5, 6]); // [4, 5, 6, 1, 2, 3]

arrAppend([1, 2, 3]) (arrEmpty()); // [1, 2, 3]
```
[run code](https://repl.it/repls/FatalWindingLight)

They represent the aggregating notion of monoidal computations.

### The `Pred` instance

The predicate function instance is a bit more interesting:

```javascript
const record = (type, o) =>
  (o[type.name || type] = type.name || type, o);

const Pred = pred => record(Pred, {pred});

const predAppend = tp => tq =>
  Pred(x => tp.pred(x) && tq.pred(x));

const predEmpty = () => Pred(_ => true);

const numLte_ = y => x => x <= y;

const numGte_ = y => x => x >= y;

const isEven = x => (x & 1) === 0;

const numBetween = (x, y) => predAppend(
  Pred(numLte_(y)))
    (Pred(numGte_(x)));

const main = predAppend(
  numBetween(5, 10))
    (Pred(isEven));

main.pred(6); // true
main.pred(7); // false
main.pred(12); // false
```
[run code](https://repl.it/repls/AggravatingAquamarineSystemadministrator)

A predicate is an unary function wrapped in a `Pred` value to distinguish it from other functions. Predicates are fixed in the type of their codomain, i.e. they always return a boolean. The `Monoid` instance let us compose simple predicates to build more complex ones. `Pred` adds type safety to our code, because we cannot use predicates in lieu of normal functions anymore or use them in a context, where booleans are meant to be combined with the `||` operator. Moreover it makes our code more declarative, because predicates are explicitly denoted.

Please note that `Pred` represents the picking notion of monoids.

### Semigroup lifting

There are some types that form only a semigroup but not a monoid.

```javascript
// Option type

const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);

const match = (tx, o) =>
  o[tx.tag] (tx);

const Option = union("Option");

const None = Option("None", {});

const Some = some => Option(Some, {some});

// Semigroup lifting

const monoidAppend = append => tx => ty =>
  match(tx, {
    None: _ => ty,

    Some: ({some: x}) => match(ty, {
      None: _ => tx,
      Some: ({some: y}) => Some(append(x) (y))
    })
  });

const monoidEmpty = () => None;

// First semigroup

const First = first => record(First, {first});

const fstAppend = tx => ty => tx; 

// auxiliary function

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

// MAIN

const xs = [Some("foo"), Some("bar"), Some("baz")],
  ys = [None, Some("bar"), Some("baz")],
  zs = [];

const main = arrFold(
  monoidAppend(fstAppend))
    (monoidEmpty());

main(xs); // Some("foo")
main(ys); // Some("bar")
main(zs); // None
```
[run code](https://repl.it/repls/SphericalComplexPrinter)

### Commutative monoids and `Dual`

`append(a) (b) === append(b) (a)`

```javascript
const record = (type, o) =>
  (o[type.name || type] = type.name || type, o);

const Dual = dual => record(Dual, {dual});

const dualAppend = append => tx => ty =>
  Dual(append(ty.dual) (tx.dual));

const dualEmpty = empty => () => Dual(empty());
```
### Monoid homomorphisms

Using a from `Task` to `Parallel` homomorphism

```javascript
const thisify = f => f({});

const comp = f => g => x =>
  f(g(x));

const record = (type, o) =>
  (o[type.name || type] = type.name || type, o);

const Task = task => record(
  Task,
  thisify(o => {
    o.task = (res, rej) =>
      task(x => {
        o.task = k => k(x);
        return res(x);
      }, rej);
    
    return o;
  }));

const tEmpty = empty =>
  () => Task((res, rej) => res(empty));

const tAppend = append => tx => ty =>
  Task((res, rej) =>
    tx.task(x =>
      ty.task(y =>
        res(append(x) (y)), rej), rej));

const Parallel = para => record(
  Parallel,
  thisify(o => {
    o.para = (res, rej) =>
      para(x => {
        o.para = k => k(x);
        return res(x);
      }, rej);
    
    return o;
  }));

const pEmpty = Parallel((res, rej) => null);

const pAppend = tx => ty => {
  const guard = (res, rej) => [
    x => (
      isRes || isRej
        ? false
        : (isRes = true, res(x))),
    e =>
        isRes || isRej
          ? false
          : (isRej = true, rej(e))];

  let isRes = false,
    isRej = false;

  return Parallel(
    (res, rej) => {
      tx.para(...guard(res, rej));
      ty.para(...guard(res, rej))
    })
};
```
