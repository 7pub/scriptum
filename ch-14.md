## Respecting the Structure with Natural Transformations

The functor type class maintains context by only operating on the values inside. A natural transformation on the other hand leaves the values untouched and only transforms the context. It is a morphism from one functor to another, while the internal structure of both functors is respected.

What does such a morphism look like? It is just a function having to be fully polymorphic in the type argument of the functor, or simply put, it must not transform the values in the functorial context. Let us start with a simple natural transformation from `Array` to `Option` and vice versa:

```javascript
// Option type

const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);

const match = (tx, o) =>
  o[tx.tag] (tx);

const Option = union("Option");

const None = Option("None", {});

const Some = some => Option(Some, {some});

// functors

const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));
  
const optMap = f => tx =>
  match(tx, {
    None: _ => None,
    Some: ({some: x}) => Some(f(x))
  });
  
// natural transformation

const optArray = tx =>
  match(tx, {
    None: () => [],
    Some: ({some}) => [some]
  });
  
const arrOption = xs =>
  xs.length === 0
    ? None
    : Some(xs[0]);
```
