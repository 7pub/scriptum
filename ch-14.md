## Combining Values: From Semigroup to Monoid

* combining values
* identity element
* a monoid under adition
* a monoid under multiplication
* the list monoid
* a type class for combining things
* First/Last
* compare
* mconcat
* combine/sequence effects in parallel/sequential
* every effect is performed once
* pure must not perform an effect ata all
* the combination of effects is monoidal
* pure f <*> x = fmap f x defines meaningful combinations of effects
* applicative have a monoidal nature
* Applicative instances must be monoidal in how they sequence their effects
* associative binary operations with an identity
* append is just a metaphor sometimes
* monoid homomorphism
* dual monoid and a append b !== b append a (non-commutative)
* product monoid instance (Monoid a,Monoid b) => Monoid (a,b) where mempty = (mempty,mempty) mappend (u,v) (w,x) = (u `mappend` w,v `mappend` x)
* Monoids provide a general approach to combining and accumulating values
* They allow us to write code that is agnostic about the method we will use to combine values, and that makes our code more reusable
* analogously to how a monoid is a structure that defines a way to combine objects,
