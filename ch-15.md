## Combining two Contexts with a function through Applicative

Functors are an incredible general algebraic structure but they lack one important capability: They cannot combine the values of two contexts. If we try to apply two functors of the same type to a binary function, we wind up with partially applied functions in a context:

```javascript
const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));
  
const add = x => y => x + y;

arrMap(add) ([1, 2, 3]); // [f, f, f]
```
We cannot apply `map` another time, because it expects a pure function `f`, not a list of partially applied functions. Fortunately we can extend the functor type class to obtain applicative functors, which remedy this shortcoming. The applicative functor type class has to aditional properties:

```javascript
const of = x => /* function body */
const ap = tf => tx => /* function body */
```
An applicative functor takes a lifted function in a context, ususally lifted by a functor and a value in a context of the same type and applies the function to the value within the context. You already knwo this pattern, it is a composition:

```javascript
const map = f => tx => /* function body */

ap()
```

* a applictive functor is a functor
* apply lifted function in a context
* the machanism is rather mechanic
* since the lifted function is within the context it is sort of object of the context
* the lifted function is applied to the values within the context through the context
* the application of the lifted function is completely determined by the rules and strucuture of the context
* applicative can apply several functorial arguments of the same functor to a pure function
* applicative preserves the product, because a multi-argument functions forms a product type
* to do so we need a morphism for multiplication `ap` and for unit `pure`
* useful for sequencing of actions/effects
* applicatives compose
* applicatives provide a way to take two computations and join them together using a function
* can process two computations in parallel
* combine two effectful values into one using a pure function
* applicative effect order is determined at compile/interpretation time
* applicative combined effects according to a fixed recipe
* with applicative the order of effects must be known in advance
* distinction between the notion of an expression as a value or as a computation
