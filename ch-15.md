## Statically Combining Contexts with a Pure Function using Applicative

Functor is an incredible general and useful algebraic structure but it lacks an important ability: We cannot lift a binary or other n-ary functions into `n` functorial contexts or in other words we cannot combine several contexts with a function. When we try anyway we get stuck with funcions in a context:

```javascript
const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));
  
const add = x => y => x + y;

arrMap(add) ([1, 2, 3]); // [f, f, f]
```
`Functor` has no means to further apply these functions, because `map` expects a single pure function not a collection of partially applied pure ones.

### Extending functor to applicative

Let us extend the `Functor` type class by deduce a subclass with two additional properties. This new type class is called `Applicative` and encodes the algebraic structure of applicative functors.

#### `of` operation

```javascript
const of = x => /* function body */;
```
`of` puts whatever value is provided in the most minimal context. It is fully polymorphic in the value. Most minimal context is a rather fuzzy term, but during this chapter you will develop a better intuition.

#### `ap` operation and the applicative pattern

```javascript
const ap = tf => tx => /* function body */;
```
`ap` is a left-associative binary function that takes a partially applied pure function `tf` in a context `t` and a value `tx` in the same context, applies `f` to `x` and returns the result value again in `t`. Depending on the context there can be none, exactly one or many `x`s within `t`.

Since `ap` expects a function within a context we must compose it with `map`, which yields the usual applicative pattern: `ap(map(f) (tx)) (ty)`.

We can compose several `ap` functions to combine `n` contexts with an `n`-ary function, as long as all contexts are of the same type.

#### Monoidal in terms of contexts

`of` and `ap` only operate on contexts and are fully polymorphic on the values inside. `of` acts like an identity context and `ap` combines two context of the same type. The resemblance to monoids is obvious. `Applicative` combines functor and monoid in a meaningful way. It only inherits from `Functor` but incorporates `Monoid` conceptually.

The pure function `f` on the other hand is not context aware at all. The context in which it is being applied to values is opaque to `f`. The pure function is exposed to this context and cannot change any property that belongs to the latter. From the perspective of the context `f`'s application is completely mechanic and deterministic.

### Applicative at the type level

If Typescript would support higher-order type constructors the applicative operations would have the following types:

```javascript
// hypothetical type
type op = <F, A>(x: A) => F<A>;
type ap = <F, A, B>(tf: F<A => B>) => (tx: F<A>) => F<B>;
```
### The two notions of expressions

Looking at an expression like `[1, 2, 3]` it is just a collection of values of the same type. This is the notion of an expression as an ordinary value. Now an applicative functor has the characteristic to create meaning. As soon as we use our array in an applicative operation it is not an ordinary value anymore but a non-deterministic computation. An array is non-deterministic because it can contain none, one or many values. This is the notion of an expression as a computation. An applicative functor turns a value into a specific computation. You can think of it as a semantics machine.

A type like `Array` that implements `Applicative` can have more than one meaningful context and thus several instances. For example, we can render arrays slightly less non-deterministic by asserting it cannot be empty. The decesive point is that applicative must not assume anything about the value(s) inside the context but must be fully polymorphic in this regard. The only thing that matters is the context.

### Static combination of contexts

Every context affects its value(s) in a certain way. The non-deterministic context, for instance, either contains none, one or many values. The crucial property of applicative functors is that they perform the effect of its context exactly ONCE, without exception. If you combine two non-deterministic computations `xs`/`ys` with a binary pure function `f` by applying `ap(map(f) (xs)) (ys)`, the non-determinism of both values is combined. You cannot ignore the first or the last one or apply either of them twice. In other words the combination of applicative contexts is static or deterministic, because you can determine from the code in what manner the contexts will be combined:

```javascript
// Functor

const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));

// Applicative

const arrAp = tf => tx =>
  arrFold(acc => f =>
    arrAppend(acc)
      (arrMap(x => f(x)) (tx)))
        ([])
          (tf);

// Foldable

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

// Semigroup

const arrAppend = xs => ys =>
  (xs.push.apply(xs, ys), xs);

// function compostion

const comp = f => g => x => f(g(x));

// MAIN

const add = x => y => x + y;

const xs = [1, 2, 3],
  ys = [0, 20, 300];

comp(arrAp)
  (arrMap(add))
    (xs)
      (ys); // [1, 21, 301, 2, 22, 302, 3, 23, 303]
```
[run code](https://repl.it/repls/HotpinkShamelessLoopfusion)

We start with a composition of `map` and `ap`, which is the applicative pattern as already mentioned. Next we pass the array values or rather the non-deterministic computations to this composition. We still cannot determine the length of both arrays because they are non-deterministic but we can anticipate that the resulting array will be the cartesian product of both input arrays. The simple example above only uses array literals so we can actually determine the length of the resulting array, which is `3 * 3 = 9`. No matter what the pure function does with its values we will always stick with a result array of the same shape, namley with exactly nine elements.

***



The part that makes the applicative computation mechanical is the shape of the resulting structure `[1, 21, 301, 2, 22, 302, 3, 23, 303]`. No matter what we do we cannot change its size, which solely depends on the two input arrays. Why just the size? Because this is the effect the array context has on its values. Arrays in the context of functors are not just collections of values but represent a non-deterministic computation, i.e. they can include none, one or many values. With applicative we do not have any influence on the number of values of the resulting array.

The effect a context can have on its value(s) is not limited to the number of resulting values. Every context has its own effect, often rather subtle ones. This is the property that renders applicative functors so general and hard to grasp. If you understood a specific applicative you are far from having understood all applicatives. It is hard to draw a general conclusion from a specific applicative instance, because the contexts of different instances are often quite different and often have nothing in common.

In order to have a more formal definition of our observation we can recapitulate that applicative is deterministic regarding its context, that is, you can tell the final shape of the context from just lookting at the code.

### Abstract from applicative application

Let us see if we can generalize the applicative pattern with a family of arity aware combinators:

```javascript
const liftA4 = ({map, ap}) => f => tw => tx => ty => tz =>
  ap(ap(ap(map(f) (tw)) (tx)) (ty)) (tz);
  
liftA4({map: arrMap, ap: arrAp})
  (w => x => y => z => [w, x, y, z])
    ([1, 2])
      (["a", "b"])
        ([true, false])
          ([[], {}]); // [[1, 'a', true, []], ...]
```
[run code](https://repl.it/repls/WhirlwindLightcyanEmacs)

`liftA4` applied to four array yields the cartesian product of them in form of an array of 4-tuples. The combinator works with any applicative functor. We can generalize the application pattern, because the applicative combination of contexts is static or known upfront respectively. Let us drop the constraints and rearrange/rename a few arguments to draw attention to the essential computational structure:

```javascript
const apply4 = v => f => w => g => x => h => y => i => z =>
  i(h(g(f(v) (w)) (x)) (y)) (z);

const sub = x => y => x - y;

apply4(1)
  (sub) (2)
    (sub) (3)
      (sub) (4)
        (sub) (5); // ((((1 - 2) - 3) - 4) - 5) === -13
```
[run code](https://repl.it/repls/EverlastingTechnoSymbols)

The nested computation has not changed. This is just a nested application of binary functions in a left-associative manner. Here is the right-associative version:

```javascript
const applyr4 = v => f => w => g => x => h => y => i => z =>
  f(v) (g(w) (h(x) (i(y) (z))));
  
const sub = x => y => x - y;

applyr4(1)
  (sub) (2)
    (sub) (3)
      (sub) (4)
        (sub) (5); // (1 - (2 - (3 - (4 - 5)))) === 3
```
[run code](https://repl.it/repls/GrouchyFakeStartup)

So our applicative computational structure is just the left-associative way of composing binary functions. Instead of `sub` and natural numbers we could have also applied `comp` and unary functions. Applicative is just functorial computation under the hood.

### Combining means sequencing or parallelizing

### `Option` instance

* applicative can only short circuit if the instance implementation of `ap` short circuits

### Function instance

* an ordinary curried function is a sufficient context but it isn't the most minimal one, which is `_const`
* does not need the applicative pattern `ap(map(f)) (g)`, because `ap(f) (g)` also works
* `ap` can have access to the initial value just as with monadic `chain`

### `Task`/`Parallel` instances

### Applicatives compose

* describe the similarity to monoid
* the lifted pure function is not aware of `ap`
* an applicative that has a monoid for its type variable is also a monoid
* pure function is object to the combination (is being applied to a value by the context within the context)
* combining means usually sequencing of contexts/effects of the same functor/type unless the context sais otherwise
* applicative effect order is usually determined at compile time unless the context sais otherwise
* with applicative the order of effects must be known in advance unless the context sais otherwise
* applicative is a semantics machine, it turns a pair tuple into a stateful computation
* as opposed to monad applicative cannot depend on the result of the previous computation
* applicative preserves the product, because a multi-argument functions are the product of their arguments
* to do so we need a morphism for multiplication `ap` and for unit `pure`
* the `liftA` arity aware function family helps to abstract from nested function call trees
