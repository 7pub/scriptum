## Statically Combining Contexts with a Pure Function using Applicative

Functor is an incredible general and useful algebraic structure but it lacks an important ability: We cannot lift a binary or other n-ary functions into `n` functorial contexts or in other words we cannot combine several contexts with a function. When we try anyway we get stuck with funcions in a context:

```javascript
const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));
  
const add = x => y => x + y;

arrMap(add) ([1, 2, 3]); // [f, f, f]
```
`Functor` has no means to further apply these functions, because `map` expects a single pure function not a collection of partially applied pure ones.

### Extending functor to applicative

Let us extend the `Functor` type class by deduce a subclass with two additional properties. This new type class is called `Applicative` and encodes the algebraic structure of applicative functors.

#### `of` operation

#### `ap` operation

```javascript
const of = x => /* function body */;
const ap = tf => tx => /* function body */;
```
`of` acts like an identity context. It puts whatever value in the most minimal available context. `ap` is a left-associative binary operation to combine two contexts. As its first argument it expects a partially applied function `f` in a context `F`, that is, the initial value `x` is already applied to `f`. As its second argument it expects another value `y` within `F`. `ap` applies `f` to `y` within `F` and returns another `F` containing the return value.

The applicative principle is limited to contexts of the same type but not to two contexts. We can compose several `ap` operations to lift a pure n-ary function `f` into `n` contexts, where `f` can combine `m` values. The distinction between `n` and `m` is important here, because their may be no, exactly one or many values within a context. The quantity depends on, well, the respective context.

`of` and `ap` do not operate on values but solely on contexts. It is the responsibility of the lifted pure function to transform and combine values contained in these contexts. Therefore you can consider the `Applicative` type class as a monoid in terms of various contexts. A monoid combines values, which may mean accumulating, aggregating or picking. An applicative accumulates, aggregates or picks contexts.

The pure function `f` on the other hand is not context aware at all. The context in which it is being applied to values is completely opaque to `f`. The pure function is exposed to this context and cannot change any property that belongs to the latter. From the perspective of the context `f`'s application is completely mechanic and deterministic.

### Applicative at the type level

```javascript
// hypothetical type
type ap = <F, A, B>(tf: F<A => B>) => (tx: F<A>) => F<B>
```
### The two notions of expressions

When we look at an expression like `[1, [2, [3, []]]]` (single linked `List` type) we can consider it as a collection of values of the same type. This is the notion of an expression as a value. But as soon as we use it as part of a functorial application, the functor turns the mere value `[1, [2, [3, []]]]` into a prioritized choice. This is the notion of an expression as a computation. It is the role of `ap` to combine two prioritized choices into a single one. The lifted pure function may transform the numbers inside `[1, [2, [3, []]]]`, but it cannot interfere with the choice itself, that is, it cannot add, drop or duplicate values, because that would alter the choice and thus the context.

* applicative functors are semantics machines

### Static combinations of contexts

The crucial aspect of applicatives results from the combination of contexts. Each effect the context has on its values is performed exactly ONCE, without exception. Let us illustrate this mechanism using a simple example with arrays:

```javascript
// Functor

const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));

// Applicative

const arrAp = tf => tx =>
  arrFold(acc => f =>
    arrAppend(acc)
      (arrMap(x => f(x)) (tx)))
        ([])
          (tf);

// Foldable

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

// Semigroup

const arrAppend = xs => ys =>
  (xs.push.apply(xs, ys), xs);

// function compostion

const comp = f => g => x => f(g(x));

// MAIN

const add = x => y => x + y;

const xs = [1, 2, 3],
  ys = [0, 20, 300];

comp(arrAp)
  (arrMap(add))
    (xs)
      (ys); // [1, 21, 301, 2, 22, 302, 3, 23, 303]
```
[run code](https://repl.it/repls/HotpinkShamelessLoopfusion)

We start with two arrays and combine them with a binary function. First we map over `[1, 2, 3]` and than we apply the resuling `[f, f, f]` structure along with the second array to `ap`. This `ap(map(f))` composition is sometime referred to as the applicative pattern and is quite common in functional programming.

The part that makes the applicative computation mechanical is the shape of the resulting structure `[1, 21, 301, 2, 22, 302, 3, 23, 303]`. No matter what we do we cannot change its size, which solely depends on the two input arrays. Why just the size? Because this is the effect the array context has on its values. Arrays in the context of functors are not just collections of values but represent a non-deterministic computation, i.e. they can include none, one or many values. With applicative we do not have any influence on the number of values of the resulting array.

The effect a context can have on its value(s) is not limited to the number of resulting values. Every context has its own effect, often rather subtle ones. This is the property that renders applicative functors so general and hard to grasp. If you understood a specific applicative you are far from having understood all applicatives. It is hard to draw a general conclusion from a specific applicative instance, because the contexts of different instances are often quite different and often have nothing in common.

In order to have a more formal definition of our observation we can recapitulate that applicative is deterministic regarding its context, that is, you can tell the final shape of the context from just lookting at the code.

### Abstract from applicative application

Let us see if we can generalize the applicative pattern with a family of arity aware combinators:

```javascript
const liftA4 = ({map, ap}) => f => tw => tx => ty => tz =>
  ap(ap(ap(map(f) (tw)) (tx)) (ty)) (tz);
  
liftA4({map: arrMap, ap: arrAp})
  (w => x => y => z => [w, x, y, z])
    ([1, 2])
      (["a", "b"])
        ([true, false])
          ([[], {}]); // [[1, 'a', true, []], ...]
```
[run code](https://repl.it/repls/WhirlwindLightcyanEmacs)

`liftA4` applied to four array yields the cartesian product of them in form of an array of 4-tuples. The combinator works with any applicative functor. We can generalize the application pattern, because the applicative combination of contexts is static or known upfront respectively. Let us drop the constraints and rearrange/rename a few arguments to draw attention to the essential computational structure:

```javascript
const apply4 = v => f => w => g => x => h => y => i => z =>
  i(h(g(f(v) (w)) (x)) (y)) (z);

const sub = x => y => x - y;

apply4(1)
  (sub) (2)
    (sub) (3)
      (sub) (4)
        (sub) (5); // ((((1 - 2) - 3) - 4) - 5) === -13
```
[run code](https://repl.it/repls/EverlastingTechnoSymbols)

The nested computation has not changed. This is just a nested application of binary functions in a left-associative manner. Here is the right-associative version:

```javascript
const applyr4 = v => f => w => g => x => h => y => i => z =>
  f(v) (g(w) (h(x) (i(y) (z))));
  
const sub = x => y => x - y;

applyr4(1)
  (sub) (2)
    (sub) (3)
      (sub) (4)
        (sub) (5); // (1 - (2 - (3 - (4 - 5)))) === 3
```
[run code](https://repl.it/repls/GrouchyFakeStartup)

So our applicative computational structure is just the left-associative way of composing binary functions. Instead of `sub` and natural numbers we could have also applied `comp` and unary functions. Applicative is just functorial computation under the hood.

### Combining means sequencing or parallelizing

### `Option` instance

* applicative can only short circuit if the instance implementation of `ap` short circuits

### Function instance

* an ordinary curried function is a sufficient context but it isn't the most minimal one, which is `_const`
* does not need the applicative pattern `ap(map(f)) (g)`, because `ap(f) (g)` also works
* `ap` can have access to the initial value just as with monadic `chain`

### `Task`/`Parallel` instances

### Applicatives compose

* describe the similarity to monoid
* the lifted pure function is not aware of `ap`
* an applicative that has a monoid for its type variable is also a monoid
* pure function is object to the combination (is being applied to a value by the context within the context)
* combining means usually sequencing of contexts/effects of the same functor/type unless the context sais otherwise
* applicative effect order is usually determined at compile time unless the context sais otherwise
* with applicative the order of effects must be known in advance unless the context sais otherwise
* applicative is a semantics machine, it turns a pair tuple into a stateful computation
* as opposed to monad applicative cannot depend on the result of the previous computation
* applicative preserves the product, because a multi-argument functions are the product of their arguments
* to do so we need a morphism for multiplication `ap` and for unit `pure`
* the `liftA` arity aware function family helps to abstract from nested function call trees
