## Statically Combining Contexts with a Pure Function using Applicative

Functor is an incredible general and useful algebraic structure but it lacks an important ability: We cannot lift a binary or other n-ary functions into `n` functorial contexts or in other words we cannot combine several contexts with a function. When we try anyway we get stuck with funcions in a context:

```javascript
const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));
  
const add = x => y => x + y;

arrMap(add) ([1, 2, 3]); // [f, f, f]
```
`Functor` has no means to further apply these functions, because `map` expects a single pure function not a collection of partially applied pure ones.

### Extending functor to applicative

Let us extend the `Functor` type class by deduce a subclass with two additional properties. This new type class is called `Applicative` and encodes the algebraic structure of applicative functors.

#### `of` operation

```javascript
const of = x => /* function body */;
```
`of` puts whatever value is provided in the most minimal context. It is fully polymorphic in the value. Most minimal context is a rather fuzzy term, but during this chapter you will develop a better intuition.

#### `ap` operation and the applicative pattern

```javascript
const ap = tf => tx => /* function body */;
```
`ap` is a left-associative binary function that takes a partially applied pure function `tf` in a context `t` and a value `tx` in the same context, applies `f` to `x` and returns the result value again in `t`. Depending on the context there can be none, exactly one or many `x`s within `t`.

Since `ap` expects a function within a context we must compose it with `map`, which yields the usual applicative pattern: `ap(map(f) (tx)) (ty)`.

We can compose several `ap` functions to combine `n` contexts with an `n`-ary function, as long as all contexts are of the same type.

#### Monoidal in terms of contexts

`of` and `ap` only operate on contexts and are fully polymorphic on the values inside. `of` acts like an identity context and `ap` combines two context of the same type. The resemblance to monoids is obvious. `Applicative` combines functor and monoid in a meaningful way. It only inherits from `Functor` but incorporates `Monoid` conceptually.

The pure function `f` on the other hand is not context aware at all. The context in which it is being applied to values is opaque to `f`. The pure function is exposed to this context and cannot change any property that belongs to the latter. From the perspective of the context `f`'s application is completely mechanic and deterministic.

### Applicative at the type level

If Typescript would support higher-order type constructors the applicative operations would have the following types:

```javascript
// hypothetical type
type op = <F, A>(x: A) => F<A>;
type ap = <F, A, B>(tf: F<A => B>) => (tx: F<A>) => F<B>;
```
### The two notions of expressions

Looking at an expression like `[1, 2, 3]` it is just a collection of values of the same type. This is the notion of an expression as an ordinary value. Now an applicative functor has the characteristic to create meaning. As soon as we use our array in an applicative operation it is not an ordinary value anymore but a non-deterministic computation. An array is non-deterministic because it can contain none, one or many values. This is the notion of an expression as a computation. An applicative functor turns a value into a specific computation. You can think of it as a semantics machine.

A type like `Array` that implements `Applicative` can have more than one meaningful context and thus several instances. For example, we can render arrays slightly less non-deterministic by asserting it cannot be empty. The decesive point is that applicative must not assume anything about the value(s) inside the context but must be fully polymorphic in this regard. The only thing that matters is the context.

### Static combination of contexts

Every context affects its value(s) in a certain way. The non-deterministic context, for instance, either contains none, one or many values. The crucial property of applicative functors is that they perform the effect of its context exactly ONCE, without exception. If you combine two non-deterministic computations `xs`/`ys` with a binary pure function `f` by applying `ap(map(f) (xs)) (ys)`, the non-determinism of both values is combined. You cannot ignore the first or the last one or apply either of them twice. In other words the combination of applicative contexts is static or deterministic, because you can determine from the code in what manner the contexts will be combined:

```javascript
// Functor

const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));

// Applicative

const arrAp = tf => tx =>
  arrFold(acc => f =>
    arrAppend(acc)
      (arrMap(x => f(x)) (tx)))
        ([])
          (tf);

// Foldable

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

// Semigroup

const arrAppend = xs => ys =>
  (xs.push.apply(xs, ys), xs);

// function compostion

const comp = f => g => x => f(g(x));

// MAIN

const add = x => y => x + y;

const xs = [1, 2, 3],
  ys = [0, 20, 300];

comp(arrAp)
  (arrMap(add))
    (xs)
      (ys); // [1, 21, 301, 2, 22, 302, 3, 23, 303]
```
[run code](https://repl.it/repls/HotpinkShamelessLoopfusion)

We start with a composition of `map` and `ap`, which is the applicative pattern as already mentioned. Next we pass the array values or rather the non-deterministic computations to this composition. We still cannot determine the length of both arrays because they are non-deterministic but we can anticipate that the resulting array will be the cartesian product of both input arrays. The simple example above only uses array literals so we can actually determine the length of the resulting array, which is `3 * 3 = 9`. No matter what the pure function does with its values we will always stick with a result array of the same shape, namley with exactly nine elements.

The effect a context can have on its value(s) is not limited to quantity. Every context has its own effect, often rather subtle ones. This is exactly the part that renders applicative functors so general and hard to grasp. If you have understood a the context of an specific applicative instance you are far from having understood the concept in general. On the one hand it is hard to draw a universal conclusion from the perspetive of a single applicativ. On the other hand it is hard to conclude from an abstract description on the variety of contexts, which often have nothing in common.

### Abstracting from nested application

The main applicative operation `ap` expects two arguments. If we can to combine more than two contexts we have to build a call tree of nested `ap` applications. However, since applicative computations are static, we can abstract from the nesting with a family of arity aware combinators:

```javascript
const liftA4 = ({map, ap}) => f => tw => tx => ty => tz =>
  ap(ap(ap(map(f) (tw)) (tx)) (ty)) (tz);
  
liftA4({map: arrMap, ap: arrAp})
  (w => x => y => z => [w, x, y, z])
    ([1, 2])
      (["a", "b"])
        ([true, false])
          ([[], {}]); // [[1, 'a', true, []], ...]
```
[run code](https://repl.it/repls/WhirlwindLightcyanEmacs)

`liftA4` applied to four arrays yields the cartesian product of the involved arrays in form of an array of 4-tuples. The combinator works with any applicative functor. Let us drop the type class constraints and rearrange/rename a few arguments to direct the attention to the essential computational structure:

```javascript
const apply4 = v => f => w => g => x => h => y => i => z =>
  i(h(g(f(v) (w)) (x)) (y)) (z);

const applyr4 = v => f => w => g => x => h => y => i => z =>
  f(v) (g(w) (h(x) (i(y) (z))));

const sub = x => y => x - y;

apply4(1)
  (sub) (2)
    (sub) (3)
      (sub) (4)
        (sub) (5); // ((((1 - 2) - 3) - 4) - 5) === -13

applyr4(1)
  (sub) (2)
    (sub) (3)
      (sub) (4)
        (sub) (5); // (1 - (2 - (3 - (4 - 5)))) === 3

```
[run code](https://repl.it/repls/EverlastingTechnoSymbols)

An applicative computation is just the left-associative variant to compose binary functions in a meaningful way. In a subsequent chapter we will see that there is another meaningful way to compose binary function, the monadic way.

### Combining means sequencing or parallelizing

Applicative does not rely on the result of the previous applicative computation. As a result such computations do not necessarily have a notion of order. Combining two applicative contexts therefore means to perform the effects either in sequence or in parallel. The important fact is that both effect have to take place exactly once. So applicative combining means either to sequence or to parallelize.

### `Option` instance

If the effect an applicative context has on its value(s) must be performed exactly once does this mean we cannot short circuit an applicative computation? Strictly speaking yes, unless the instance implementation of `ap` itself provides this ability:

```javascript
const Option = union("Option");

const None = Option("None", {});
const Some = some => Option(Some, {some});

const optMap = f => tx =>
  match(tx, {
    None: _ => None, // short circuiting
    Some: ({some: x}) => Some(f(x))
  });

const optAp = tf => tx =>
  match(tf, {
    None: _ => None, // short circuiting
    Some: ({some: f}) => {
      return match(tx, {
        None: _ => None, // short circuiting
        Some: ({some: x}) => Some(f(x))
      });
    }
  });

const comp = f => g => x => f(g(x));
const add = x => y => x + y;

comp(optAp) (optMap(add)) (Some(2)) (Some(3)); // Some(5)
comp(optAp) (optMap(add)) (None) (Some(3)); // None
```
[run code](https://repl.it/repls/CyanCuddlyOrganization)

With the `Option` type, whenever the computation comes upon the `None` case, no matter at what position, the whole applicative computation is short circuited and the pure function (namely `add`) never evaluated.

### Function instance

* an ordinary curried function is a sufficient context but it isn't the most minimal one, which is `_const`
* does not need the applicative pattern `ap(map(f)) (g)`, because `ap(f) (g)` also works
* `ap` can have access to the initial value just as with monadic `chain`

### `Task`/`Parallel` instances

### Applicatives compose

* describe the similarity to monoid
* the lifted pure function is not aware of `ap`
* an applicative that has a monoid for its type variable is also a monoid
* pure function is object to the combination (is being applied to a value by the context within the context)
* combining means usually sequencing of contexts/effects of the same functor/type unless the context sais otherwise
* applicative effect order is usually determined at compile time unless the context sais otherwise
* with applicative the order of effects must be known in advance unless the context sais otherwise
* applicative is a semantics machine, it turns a pair tuple into a stateful computation
* as opposed to monad applicative cannot depend on the result of the previous computation
* applicative preserves the product, because a multi-argument functions are the product of their arguments
* to do so we need a morphism for multiplication `ap` and for unit `pure`
* the `liftA` arity aware function family helps to abstract from nested function call trees
