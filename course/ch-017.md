## Combining Effects with Actions using Monad

### The limitation of applicative

In the chapter about applicatives we have learned that an applicative effect may depend on a previous effect but we cannot control an effect depending on a previous value. It turns out that despite this limitation applicative computations are applicable for a surprising number of scenarios. However, they are not always enough. We need a slightly less general, slightly more expressive alternative.

### Extending `Applicative` by `Monad`

Provided you have understood applicative functors it is only a minor step to comprehend monads. Their sole purpose is to overcome the limitation of applicatives. Before we take a close look into the `Monad` type class we will ascertain what they are not:

_Monads are no means to handle side effects!_

There is special type to do this. Monad and applicative are just two differently expressive ways to combine this type or types that handle any other computational effect.

#### From pure functions to actions

So far we lifted n-ary functions into the context of `n` applicative values. If the next effect should depend on the previous value we need more than a pure function. We need one that returns a value in an effectul context of the same type itself. This type of function is called action. An action is not impure, but it may represent an effectful computation, provided it is used as part of an applicative or monadic computation:

```javascript
// Applicative

const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));

const arrAp = tf => xs =>
  arrFold(acc => f =>
    arrAppend(acc)
      (arrMap(x => f(x)) (xs)))
        ([])
          (tf);

// auxiliary functions

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

const arrAppend = xs => ys =>
  (xs.push.apply(xs, ys), xs);

const comp = f => g => x => f(g(x));

// action

const foo = x => y =>
  y === null
    ? []
    : [x, y];

// MAIN

// result of the action interpreted as a value
arrAppend(foo(1) (2)) (foo(3) (null)); // [1, 2, 3]

// result of the action interpreted as a computation
arrAp(arrMap(foo) ([1, 2])) ([3, null]); // [[1, 3], [], [2, 3], []]
```
[run code](https://repl.it/@scriptum/TubbyUnconsciousVolume)

If we use `foo` in a normal context it return value is treated like an ordinary value. However, if we use it as part of an applicative computation, the return value behaves differently. It now represents a computation, namely a non-deterministic computation in the example above. Since `foo` is an action that returns a value wrapped in an effectful context the next effect can depend on the previous value. But now we are stuck with a nested context. The desired result is `[1, 3, 2, 3]`. Obviously actions are only half the solution.

#### The `join` operation

Let us just join to effectful contexts:

```javascript
const arrEmpty = () => [];

// Monad

const arrJoin = xs =>
  arrFold(arrAppend)
    (arrEmpty())
      (xs);

// MAIN

arrJoin(
  arrAp(
    arrMap(x => y =>
      y === null
        ? []
        : [x, y])
            ([1, 2]))
              ([3, null])); // [1, 3, 2, 3]
```
[run code](https://repl.it/@scriptum/FragrantSugaryObjectpool)

`join` is sufficient and yields the expected result. Composing `join`, `ap` and `map` is not that convenient. We can do better.

#### The `chain` operation

`chain` takes an effectful context from a previous functorial computation and an action, transforms the value(s) inside the context and returns a new context of the same type with the transformed value(s) inside:

```javascript
// Monad

const arrChain = mx => fm =>
  arrFold(acc => x =>
    arrAppend(acc) (fm(x))) ([]) (mx);

// MAIN

arrChain([1, 2]) (x =>
  arrChain([3, null]) (y =>
    y === null
      ? []
      : [x, y])); // [1, 3, 2, 3]
```
[run code](https://repl.it/@scriptum/HarmoniousAdorableScript)

In other functional languages this combinator is called `flatmap`.

### Function instance

* short circuit example
* can chose the next function depending on the previous value and apply it onece, twice, several times or not at all

### Value-effect dependency and evaluation order

* a monad depends on the previous effect of a monadic computation
* a monad may depend on the previous result of a monadic computation

Given are two effectul computations `F<A>` and `F<B>`. It applies:

```
F   is an effectul context
A/B are values inside effectful contexts
~   denotes a "x may depend on y" relation
-   denotes a "x depends on y" relation
</> denotes the direction of an dependency

Applicative allows:
F <~ F

Monad allows:
F <- F
A <~ F
```
* usually sequence effects, depends on the instance though
* inherently non-deterministic concerning the effects?

### How values affect effects

### Monads at the type level

* the reverse `chain` combinator is used for the sake of symetry
* `chain` is an application operator as well as `map`/`ap`

```
<   A, B>( f:   (x: A) => B ) => ( x:   A ) =>   B ; // function application
<F, A, B>( f:   (x: A) => B ) => (tx: F<A>) => F<B>; // functor lifting
<F, A, B>(tf: F<(x: A) => B>) => (tx: F<A>) => F<B>; // applicative lifting
<M, A, B>(ft: (x: A) => M<B>) => (tx: M<A>) => M<B>; // monadic binding
```
#### Monadic laws

* left identity
* right identity
* associativity

### Action composition Ã  la Kleisli

* show implementation of compk, reverse pipek (kleisli composition)

The reason the `chain` and not `kleisli` is part of the `Monad` API is that the both operations, which are associated to `Functor` and `Applicative`, are function application rather than function composition.

### Abstracting from nested application

* explain the difference between liftA2 and liftM2 (as opposed to Haskell)
* illustrate that liftM2 based on CPS is still more readable than deeply nested monad bindings
* show implementation of liftM2 combinator family
* show implementation of compk3 and pipek3 combinator families
* example with `Task` instance
* monad recursion
* monads allow also allow composition of actions
ma `bind` (f >=> g) = (ma `bind` f) `bind` g              -- bind = (>>=)
                    = (`bind` g) . (`bind` f) $ ma 
                    = join . fmap g . join . fmap f $ ma
with flipped >>=:
((g <=< f) =<<)  =  (g =<<) . (f =<<)  =  join . (g <$>) . join . (f <$>)
