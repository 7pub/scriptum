## Combining Effects with Actions using Monad

### The limitation of applicative

In the chapter about applicatives we have learned that an applicative effect may depend on a previous effect but we cannot control an effect depending on a previous value. It turns out that despite this limitation applicative computations are applicable for a surprising number of scenarios. However, they are not always enough. We need a slightly less general, slightly more expressive alternative.

### Extending `Applicative` by `Monad`

Provided you have understood applicative functors it is only a minor step to comprehend monads. Their sole purpose is to overcome the limitation of applicatives. Before we take a close look into the `Monad` type class we will ascertain what they are not:

_Monads are no means to handle side effects!_

There are special types that do this. Monad and applicative are just two ways to combine these types.

#### From pure functions to actions

So far we lifted n-ary functions into the context of `n` applicative values. If the next effect should depend on the previous value we need more than a pure function. We need one that returns a value in an effectul context of the same type. This type of function is called action. An action is not impure but it represents an effectful computation, as soon as it part of an functorial computation.

#### The `join` operation

#### The `chain` operation

#### Monadic laws

### Value-effect dependency

Given are two effectul computations `F<A>` and `F<B>`. It applies:

```
F   is an effectul context
A/B are values inside effectful contexts
~   denotes a "x may depend on y" relation
-   denotes a "x depends on y" relation
</> denotes the direction of an dependency

Applicative allows:
F <~ F

Monad allows:
F <- F
A <~ F
```
### Monads at the type level

```
<   A, B>( f:   (x: A) => B ) => ( x:   A ) =>   B ; // function application
<F, A, B>( f:   (x: A) => B ) => (tx: F<A>) => F<B>; // functor lifting
<F, A, B>(tf: F<(x: A) => B>) => (tx: F<A>) => F<B>; // applicative lifting
<M, A, B>(ft: (x: A) => M<B>) => (tx: M<A>) => M<B>; // monadic joining
```
### Monadic evaluation order

### Abstracting from nested application

***

* instead of lifting a pure function into several contexts of the same type and combining them inside that context (applicative) a monadic computation forms this nested structure itself and can create a context itself, outside of the context so to speak
* while applicative is object to the context monad is  subject
* monads can be commutative (reader)
* monads don't make a function pure, a special type like `IO` does that, which you cannot escape from (`IO a -> a` is not possible)
* a functor is a semantics machine and applicative/monad are ways to sequence this semantics (statically or dynamically respectively)
* a monadic action creates its own context and thus is the context or at least part of the context.
* an action is aware of both `>>=` and the context, because it controls `>>=` and creates its own context as its result value
* monad is non-deterministic in terms of context
* can short circuit everywhere independently of `chain`'s specific implementation
* as opposed to applicative monad depends on the result of the previous computation
* flattens or joins to contexts
* compare (a -> M b) -> M a -> M b with F (a -> b) -> F a -> F b
* use the 2-notion of exp example of applicative once with `of` and once without `of`
