## Dynamically Combining two Contexts with a Kleisi Arrow using Monad

### The limitation of applicative

In the last chapter we have seen that an applicative functor combines two contexts in a static way and the resulting context is therefore deterministic:

```javascript
const funAp = tf => tg => x =>
  tf(x) (tg(x));
  
const log = x => console.log(x);

const myDiv = env => x => y => {
  const r = x / y;
  if (env.debug) log(r);
  return r;
};

const mySqr = env => x => {
  const r = x * x;
  if (env.debug) log(r);
  return r;
};

// within liftedFun we can use f and g without explicitly passing env

const main = funAp(
  funAp(env =>
    env.y === 0
      ? _ => _ => _ => Infinity
      : f => g => x => f(g(x)) (env.y))
        (myDiv))
          (mySqr);

main({debug: true, y: 4}) (6); // logs 36, 9 and yields 9
main({debug: true, y: 0}) (6); // logs nothing and yields Infinity
```
If the `y` property of the environment is `0` we know upfront that the result is `Infinity`, so it would make sense to short circuit the computation. However, with applicative we have to pass through all contexts by redundantly applying the lambda `_ => _ => _ => Infinity`. We are stuck again.

### Extending applicative by monad

#### `join` and `chain` operation

#### Monadic laws

### Value dependency and order

### Monad at the type level

### Dynamic combination of contexts

### Abstracting from nested application

***

* instead of lifting a pure function into several contexts of the same type and combining them inside that context (applicative) a monadic computation forms this nested structure itself and can create a context itself, outside of the context so to speak
* while applicative is object to the context monad is  subject
* monads can be commutative (reader)
* monads don't make a function pure, a special type like `IO` does that, which you cannot escape from (`IO a -> a` is not possible)
* a functor is a semantics machine and applicative/monad are ways to sequence this semantics (statically or dynamically respectively)
* a monadic action creates its own context and thus is the context or at least part of the context.
* an action is aware of both `>>=` and the context, because it controls `>>=` and creates its own context as its result value
* monad is non-deterministic in terms of context
* can short circuit everywhere independently of `chain`'s specific implementation
* as opposed to applicative monad depends on the result of the previous computation
