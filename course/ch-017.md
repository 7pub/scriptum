## Dynamically Combining two Contexts with a Kleisi Arrow using Monad

### The limitation of applicative

In the last chapter we saw that an applicative functor combines two contexts in a static way and the resulting context is therefore deterministic. Here is a computation with an implicitly shared environment:

```javascript
const funAp = tf => tg => x =>
  tf(x) (tg(x));
  
const log = x => console.log(x);

const myDiv = env => x => y => {
  const r = x / y;
  if (env.debug) log(r);
  return r;
};

const mySqr = env => x => {
  const r = x * x;
  if (env.debug) log(r);
  return r;
};

const main = funAp(
  funAp(env =>
    env.y === 0
      ? _ => _ => _ => Infinity
      : f => g => x => f(g(x)) (env.y))
        (myDiv))
          (mySqr);

main({debug: true, y: 4}) (6); // logs 36, 9 and yields 9
main({debug: true, y: 0}) (6); // logs nothing and yields Infinity
```
[run code](https://repl.it/@scriptum/EcstaticPuzzlingDemoware#index.js)

If the `y` property of the environment is `0` we know upfront that the result is `Infinity`, so it would make sense to short circuit the computation. However, with applicative we have to pass through all contexts by redundantly applying the lambda `_ => _ => _ => Infinity`. We are stuck again. What we strive for is combining contexts in a dynamic manner depending on previous values.

### Extending applicative by monad

Provided you have understood functor and applicative functor respectively it is only a minor step to comprehend monad, because the latter extends the former two in order to overcome their limitations.

#### The `join` operation

#### The `chain` operation

#### Kleisli arrows

#### Monadic laws

### Dynamic combination and value dependency

* order

### Monad at the type level

### Abstracting from nested application

***

* instead of lifting a pure function into several contexts of the same type and combining them inside that context (applicative) a monadic computation forms this nested structure itself and can create a context itself, outside of the context so to speak
* while applicative is object to the context monad is  subject
* monads can be commutative (reader)
* monads don't make a function pure, a special type like `IO` does that, which you cannot escape from (`IO a -> a` is not possible)
* a functor is a semantics machine and applicative/monad are ways to sequence this semantics (statically or dynamically respectively)
* a monadic action creates its own context and thus is the context or at least part of the context.
* an action is aware of both `>>=` and the context, because it controls `>>=` and creates its own context as its result value
* monad is non-deterministic in terms of context
* can short circuit everywhere independently of `chain`'s specific implementation
* as opposed to applicative monad depends on the result of the previous computation
* flattens or joins to contexts
* compare (a -> M b) -> M a -> M b with F (a -> b) -> F a -> F b
* use the 2-notion of exp example of applicative once with `of` and once without `of`
