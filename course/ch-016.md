## Combining Effects with Pure Functions using Applicative

**[Editor's note: This chapter is under edit]**

Functor is an incredible general and useful algebraic structure but it lacks an important ability: We cannot lift a binary or other n-ary functions into `n` effectful contexts. In other words we cannot combine several effects with a function. When we try anyway we get stuck with functions in an effectful context:

```javascript
const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));
  
const add = x => y => x + y;

arrMap(add) ([1, 2, 3]); // [f, f, f]
```
`Functor` has no means to further apply these functions, because `map` expects a single pure function not a collection of partially applied ones.

### Extending functor by applicative

Let us extend the `Functor` type class by deriving a subclass with two additional properties. This new type class is called `Applicative` and encodes the algebraic structure of applicative functors.

#### `of` operation

```javascript
const of = x => /* function body */;
```
`of(x)` puts a pure value `x` into an effectful context without actually performing the effect. The operation is fully polymorphic in `x`. You can think of such an effectful context as one with a potential for an effect.

`of` resembles `empty` of the `Monoid` type class. Just like `empty` represents the identity element of a monoidal type, which leaves the other monoidal value unchanged when combined, `of` creates the identity context of an applicative type, which leaves the effectful context of the other applicative value unchanged when combined.

#### `ap` operation and the applicative pattern

```javascript
const ap = tf => tx => /* function body */;
```
`ap` is a left-associative binary function that takes an applicative `tf` consisting of a partially applied pure function `f` in an effectful context `t` and another apllicaitve `tx` consisting of a value `x` in a context `t` of the same type, applies `f` to `x` within `t` and returns the result value again wrapped in `t`. Depending on the effectful context there can be none, exactly one or many `x` values inside `t`.

Since `ap` expects a function within an effectful context, we must compose `f` with `map` to get `ft`. This composition forms the so called applicative pattern: `ap(map(f) (tx)) (ty)`.

We can compose any number of `ap` operations to combine `n` effectful contexts with an `n`-ary function, provided all contexts are of the same type: `ap(ap(map(f) (tx)) (ty)) (tz)`.

#### Applicative laws

Every applicative instance have to comply with the following laws:

```
~ denotes equivalence
f denotes a pure function
x denotes a pure value
tx denotes a value in an effectful context

ap(of(id)) (tx) ~ tx // identity
ap(of(f)) (of(x)) ~ of(f(x)) // homomorphism
ap(tx) (of(y)) ~ ap(of(f => f(y))) (tx) // interchange
ap(ap(ap(of(comp)) (tx)) (ty)) (tz) ~ ap(tx) (ap(ty) (tz)) // composition
```
#### No escape from the applicative context

Just like a normal functor an applicative functor preserves the effectful context but as opposed to the former it does not preserve the structure of its input. When you apply `ap` to two non-deterministic computations `[1, 2, 3]` and `[4, 5, 6]`, for instance, you get something back of shape `[?, ?, ?, ?, ?, ?, ?, ?, ?]`, which obviously has a different structure than the input.

What applicative inherits from functor is the characteristics that you cannot escape its context, namely `[]` in the above example. Sure, you can create a suitable getter or fold for a specific `Applicative` instance, but this is beyond the applicative functor API. Besides you either lose information by picking a particular value or by aggregating it in a way that the process is irreversible. In general it applies that once a value is inside a functor, it is stuck in this very functor.

### Effect/effect dependency and order

Every applicative context has a specific effect on its value(s). The non-deterministic effect, for instance, embodies a computation that may yield none, one or many results. The crucial property of applicative functors is that the next effect may depend on previous one:

```javascript
// Functor

const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));

// Applicative

const arrAp = tf => tx =>
  arrFold(acc => f =>
    arrAppend(acc)
      (arrMap(x => f(x)) (tx)))
        ([])
          (tf);

// auxiliary functions

const comp = f => g => x => f(g(x));

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

const arrAppend = xs => ys =>
  (xs.push.apply(xs, ys), xs);

const add = x => y => x + y;

// MAIN

const main = comp(
  arrAp)
    (arrMap(add));
    
main([0, 1, 2])
  ([10, 20, 30]); // [10, 11, 12, 20, 21, 22, 30, 31, 32]
    
main([0])
  ([10, 20, 30]); // [10, 20, 30]

main([])
  ([10, 20, 30]); // []
```
[run code](https://repl.it/@scriptum/HotpinkShamelessLoopfusion)

The non-deterministic effect of the array type is reified in the length of the array, because it is a linear data type, therefore its shape can only vary in the number of elements it contains. Let us pick a more simple notation to disclose the view on the effect/effect dependency: 

* `[0, 1, 2]`/`[10, 20, 30]` ~ `3 * 3 = 9`
* `[0]`/`[10, 20, 30]`       ~ `1 * 3 = 3`
* `[]`/`[10, 20, 30]`        ~ `0 * 3 = 0`

Now it is obvious that the second effect depends on the first one. However, this is only a single, specific effectful context. As already mentioned in the functor chapter of this course there is a great variety of effects and not all of them encode a depdendency between the previous and the next effect.

The variety of effectful contexts is what renders applicative functors so general and hard to grasp. If you understood the context of a specific `Applicative` instance you are far from having understood the applicative concept in all its manifastations. Then again, if you attempt to approach the concept the other way around it is not going to get any easier. Starting from a highly abstract description of the concept it is impossible to envision all the effectful computations you can express with it.

Now that we have learned about applicatives with and without an effect/effect dependency it stands to reason that several applicatives of the same type can either run in sequence or in parallel. Since Javascript is a single-threaded language a parallel evaluation is only possible along with asynchronous computations and as a matter of fact there is a distinct type called `Parallel`, whose `Applicative` instance runs in parallel. We will examine this instance in a previous section of this chapter.

***
### `Option` instance

We claimed that an applicative effect may depend on a previous one. The applicative instance of the `Option` type illustrates this behavior, because it can short circuit the rest of the computation, i.e. an effect can prevent subsequent effects from being performed:

```javascript
// OPTION

const Option = union("Option");

const None = Option("None", {});
const Some = some => Option(Some, {some});

// Functor

const optMap = f => tx =>
  match(tx, {
    None: _ => None, // short circuiting
    Some: ({some: x}) => Some(f(x))
  });

// Applicative

const optOf = x => Some(x);

const optAp = tf => tx =>
  match(tf, {
    None: _ => None, // short circuiting
    Some: ({some: f}) => {
      return match(tx, {
        None: _ => None, // short circuiting
        Some: ({some: x}) => Some(f(x))
      });
    }
  });

// auxiliary functions

const comp = f => g => x => f(g(x));
const add = x => y => x + y;

// MAIN

comp(optAp)
  (optMap(add))
    (Some(2))
      (Some(3)); // Some(5)
      
comp(optAp)
  (optMap(add))
    (None)
      (Some(3)); // None
```
[run code](https://repl.it/@scriptum/CyanCuddlyOrganization)

As soon as the applicative computation comes upon the `None` case the rest of the computation is short circuited and the pure function `add` is never evaluated. `Option` captures computations that may not yield a result at all. The type makes this kind of effect explicit and enforces that both cases are always taken care of.

### Function instance

The function applicative encodes the notion of a computation with a common read-only environment. You can use it to implicitly thread configuration or other shared data throughout a composition, that is, without having to pass the argument explicitly:

```javascript
// FUNCTION

// Applicative

const funAp = tf => tg => x =>
  tf(x) (tg(x));

// auxiliary functions

const log = x => console.log(x);

const myDiv = env => x => {
  const r = x / env.y;
  if (env.debug) log(r);
  return r;
};

const mySqr = env => x => {
  const r = x * x;
  if (env.debug) log(r);
  return r;
};

// MAIN

const main = funAp(
  funAp(env => f => g => x =>
//      ^^^ only place in the code where env is explicitly stated
    f(g(x)))
      (myDiv))
        (mySqr);

main({debug: true, y: 4}) (6); // logs 36, 9 and yields 9
```
[run code](https://repl.it/@scriptum/NoteworthyLovingCode)

Please note that for the sake of simplycity I used logging as a side effect in the example above. The `Applicative` instance of the function type is a special case by not requiring the applicative pattern. The `ap` operation expects a value wrapped in an applicative context. Both the value and the context is a function in our case. So in order to satisfy `ap`'s type we need a function wrapped in another function, which is precisely the description of a curried function one. The function `env => f => g => x => ...` passed to `funAp` is such a curried function, hence we do not need the initial lifting through `map`. `funOf` works on the same principle: It takes a function and wraps it into another function that just provides enough context: `x => _ => x`.

As you can see `env` is referred to only once within the applicative computation, even though each involved functions requires it as an argument. We successfully abstracted the it away. This comes in hand especially for larger compositions with a lot of argument passing going on. 

### `Parallel` instance

TODO

### Applicative at the type level

If Typescript would support higher-order type constructors the applicative operations would have the following types:

```
// hypothetical type
type op = <F, A>(x: A) => F<A>;
type ap = <F, A, B>(tf: F<(x: A) => B>) => (tx: F<A>) => F<B>;
```
The type level unlocks the view at the internal mechanics of applicative computations. In `F<(x: A) => B>` the pure function `(x: A) => B` is inside the effectful context `F`, that is, it is not aware of `F` at all. From the perspective of the pure function the entire applicative computation is completely opaque. It does neither know anything about the effectful context nor does it have control over the type class operations `ap` and `of`. Consequently `f` cannot modify a single property of the context but only the value(s) inside. It is fully polymorphic on the context.

Let us compare applicative lifting with functor and function application to show the symmetry of these types:

```
<   A, B>( f:   (x: A) => B ) => ( x:   A ) =>   B ; // function application
<F, A, B>( f:   (x: A) => B ) => (tx: F<A>) => F<B>; // functor lifting
<F, A, B>(tf: F<(x: A) => B>) => (tx: F<A>) => F<B>; // applicative lifting
```
So applicative computations are just function application inside a context. Moreover, applicative differs from functor in that the pure function `tf` is wrapped in a context `F<(x: A) => B>`. But what does that exactly mean? Well, in order to get `f` into the context `t` we previously applied it to a functor through `map`, that is, `ft` is a partially applied function. It is already applied to a applicative value and now we can applie it to another effectful value, even though the function is inside an effectful context. This is the mechanism that allows applicative to combine effects with a pure multi-argument function.

#### Type-level monoid

On the type level an applicative is a monoid, because it preserves the product. There is an isomorphism between both but I will not go into details. All I want to do is highlight the connection between both algebraic structures.

Simply put you can think of an applicative as a combination of functor and monoid. The functorial part lifts an n-ary pure function into the effectful context of `n` applicatives so that the function can transform the values inside. The monoidal part combines these `n` effectful contents into a single one. `of` creates the necessary identity context.

### Abstracting from nested applications

`ap` expects only two arguments. If we want to combine more than two effects we have to build a call tree of nested `ap` applications. Fortunately, applicative computations work in a rather mechanical way, because an applicative effect cannot depend on a previous value. This trait allows us to abstract from the nested structure with a family of arity aware combinators:

```javascript
const liftA4 = ({map, ap}) => f => tw => tx => ty => tz =>
  ap(ap(ap(map(f) (tw)) (tx)) (ty)) (tz);
  
const main = liftA4(
  {map: arrMap, ap: arrAp})
    (w => x => y => z => [w, x, y, z]);
    
main(
  [1, 2])
    (["a", "b"])
      ([true, false])
        ([[], {}]); // [[1, 'a', true, []], ...]
```
[run code](https://repl.it/@scriptum/WhirlwindLightcyanEmacs)

`main` applied to four arrays yields the cartesian product of the involved arrays in form of an array of 4-tuples. The `liftA4` combinator is ad-hoc polymorphic and works with any applicative functor. Let us drop the type class constraints and rearrange/rename a few arguments to direct the attention to the essential computational structure:

```javascript
const apply4 = v => f => w => g => x => h => y => i => z =>
  i(h(g(f(v) (w)) (x)) (y)) (z);

const applyr4 = v => f => w => g => x => h => y => i => z =>
  f(v) (g(w) (h(x) (i(y) (z))));

const sub = x => y => x - y;

apply4(1)
  (sub) (2)
    (sub) (3)
      (sub) (4)
        (sub) (5); // ((((1 - 2) - 3) - 4) - 5) === -13

applyr4(1)
  (sub) (2)
    (sub) (3)
      (sub) (4)
        (sub) (5); // (1 - (2 - (3 - (4 - 5)))) === 3

```
[run code](https://repl.it/@scriptum/EverlastingTechnoSymbols)

Applicative computations are just compositions of binary functions under the hood. There are two meaningful ways to compose such functions: Either left or right associative. Applicative uses the former. In a subsequent chapter we will see that there is another meaningful way to compose binary functions - the monadic way.

### Applicatives compose

Since applicatives are functors they compose, i.e. we can compose effectful values. I want to take the chance and demonstrate the process of abstracting in functional programming on the following a bit more complex example. We start with the most detailed encoding and then try to abstract from boilerplate and common patterns.

When we combine composed/nested applicatives like `Task(Some([1, 2, 3]))` and `Task(Some([4, 5, 6]))`, we have to deal with the applicative pattern `ap(map(f) (x)) (y)`, which renders the process quite complex and cumbersome:

```javascript
taskAp(
  taskMap(x => y =>
    optAp(
      optMap(x_ => y_ =>
        arrAp(
          arrMap(add) (x_)) (y_)) (x)) (y));
```
This is the applicative operation to handle an async computation that may fail or yields any number of results. We can get rid of the lambdas by using point-free style:

```javascript
taskAp(
  taskMap(
    comp(optAp)
      (optMap(
        comp(arrAp)
          (arrMap(add)))));
```
The point-free encoding removes some boilerplate to direct the view to the applicative pattern. We can use the `liftA` function family to abstract from this pattern:

```javascript
comp3(
  tLiftA2)
    (optLiftA2)
      (arrLiftA2)
        (add);
```
The implementation above is pretty easy to read. Let us put everything together to see how it works:

```javascript
// polymorphic lift

const liftA2 = ({map, ap}) => f => tx => ty =>
  ap(map(f) (tx)) (ty);

// TASK

const Task = task => record(
  Task,
  thisify(o => {
    o.task = (res, rej) =>
      task(x => {
        o.task = k => k(x);
        return res(x);
      }, rej);
    
    return o;
  }));

// Functor

const taskMap = f => tx =>
  Task((res, rej) =>
    tx.task(x => res(f(x)), rej));

// Applicative

const taskAp = tf => tx =>
  Task((res, rej) =>
     tf.task(f =>
       tx.task(x =>
         res(f(x)), rej), rej));

const taskLiftA2 = liftA2({map: taskMap, ap: taskAp});

const taskOf = x => Task((res, rej) => res(x));

// OPTION

// Applicative

const optLiftA2 = liftA2({map: optMap, ap: optAp});

// ARRAY

// Applicative

const arrLiftA2 = liftA2({map: arrMap, ap: arrAp});

// auxiliary functions

const thisify = f => f({});
const comp3 = f => g => h => x => f(g(h(x)));

// MAIN

const tttx = taskOf(optOf([1, 2, 3])),
  ttty = taskOf(optOf([10, 20, 30])),
  tttz = taskOf(None);

const main = comp3(
  tLiftA2)
    (optLiftA2)
      (arrLiftA2)
        (add)
          (tttx)
            (ttty);

const main2 = comp3(
  tLiftA2)
    (optLiftA2)
      (arrLiftA2)
        (add)
          (tttx)
            (tttz);

main.task(x => x); // Task(Some([11, 21, 31, 12, 22, 32, 13, 23, 33]))
main2.task(x => x); // Task(None)
```
[run code](https://repl.it/@scriptum/ValidBlushingVolume)

As you can see applicative functors allow as to combine two composed effects. As I have mentioned before the thrilling feature of applicatives as well as normal functors is their generality. We can apply them to a variety of composed applicative types and they will always work as expected. This means we can reuse functions that operate within effectful contexts. We have achieved a level of reusability that has no equal.

### Applicative monoids

Every applicative that is a monoid in its type parameter, i.e. contains monoidal values forms itself a monoid in a mechanic fashion:

```javascript
// ad-hoc polymorphic functions

// Applicative

const liftA2 = ({map, ap}) => f => tx => ty =>
  ap(map(f) (tx)) (ty);

// Monoid

const appmAppend = ({liftA2, append}) => tx => ty =>
  liftA2(append) (tx) (ty);

const appmEmpty = ({of, empty}) =>
  () => of(empty());

// NUMBER

// Monoid under addtion

const sumAppend = x => y => x + y;

const sumEmpty = () => 0;

// MAIN

const main = appmAppend(
  {liftA2: arrLiftA2, append: sumAppend});

const main2 = appmAppend(
  {liftA2: arrLiftA2, append: sumAppend});

main([1, 2, 3])
  ([10, 20, 30]); // [11, 21, 31, 12, 22, 32, 13, 23, 33]

main2([1, 2, 3])
  (appmEmpty({of: arrOf, empty: sumEmpty}) ()); // [1, 2, 3]
```
[run code](https://repl.it/@scriptum/TimelyVibrantCybernetics)

Please note that the `appm` prefix of `appmAppend`/`appmEmpty` stands for applicative monoid. We could have make a `AppMonoid` type wrapper but since scriptum pursues dictionary passing style and thus can have multiple monoid instances per data type, we just skip the type boilerplate.

### Editor's note

If you enjoyed this chapter please 🌟 the repo here on Github or share it on your preferred social media platform. If you found a mistake or inaccuracy or want to propose an improvement please file an issue/feature. Thank you.

[&lt; prev chapter](https://github.com/kongware/scriptum/blob/master/course/ch-015.md) | [TOC](https://github.com/kongware/scriptum#functional-programming-course-toc) | [next chapter &gt;](https://github.com/kongware/scriptum/blob/master/course/ch-019.md)
