## Linear Data Flow and Flat Composition Syntax

**[Editor's note: this chapter needs edit]**

There are two ways to obtain method chaining in Javascript, either by relying on the [prototype system](https://repl.it/@scriptum/CheapTurquoiseUnit) or by using plain old Javascript [object factories](https://repl.it/@scriptum/RegalTriflingFactor). While the former is language specific and encodes the idea of object oriented programming, object factories are quite inefficient as soon as continuously to be created objects include a larger numbers of methods. In this chapter we will therefore stick with function composition and explore techniques to reduce nesting.

### Prefix notation and S-expressions

Functions in Javascript are written in prefix notation, i.e. the name comes first and is followed by the argument list. Prefix notation leads to nested functions calls, which resemble Lisp style S-expressions:

```Javascript
const sub = x => y => x - y;

sub(
  sub(
    sub(
      sub(1) (2)) (3)) (4)) (5); // -13
```
We can avoid nested syntax using native operators, which are written in infix position:

```Javascript
1 - 2 - 3 - 4 - 5; // -13
```
The evaluation order of expressions with infix operators is determined by their precedence and associativity. Subtraction, for instance, has a higher precedence than multiplication

```Javascript
1 + 2 * 3;   // 7 (predefined precedence)
(1 + 2) * 3; // 9 (enforced precedence)
```
and is left-associative

```Javascript
1 - 2 - 3 - 4 - 5;         // -13 (left-associative by default)
(1 - (2 - (3 - (4 - 5)))); // 3 (right-associative by parentheses)
```
Unfortunately, we cannot define custom infix operators in Javascript but have to resort to operator functions, which are again in prefix position. So are we condemned to build nested S-expressions?

### Reduce nesting with function composition

A bunch of arity aware function composition functions allow us to reduce the syntactic noise:

```javascript
const comp ...
const comp3 ...

const comp4 = f => g => h => i => x =>
  f(g(h(i(x))));

const comp5 ...
const comp6 ...
...

const sub = x => y => x - y;

comp4(
  sub(1))
  (sub(2))
  (sub(3))
  (sub(4))
  (5); // (1 - (2 - (3 - (4 - 5)))) = 3
```
[run code](https://repl.it/@scriptum/CheapDrearyGenre)

Since function application is not associative we need another operator function with its arguments flipped and an inverted `comp` function:

```javascript
const pipe...
const pipe3...

const pipe4 = i => h => g => f => x =>
  f(g(h(i(x))));

const pipe5...
const pipe6...
...

const sub_ = y => x => x - y;

pipe4(
  sub_(2))
  (sub_(3))
  (sub_(4))
  (sub_(5))
  (1); // ((((1 - 2) - 3) - 4) - 5) = -13
```
[run code](https://repl.it/@scriptum/CapitalSociableUser)

### Variadic function composition

Arity aware combinators are somewhat impractical, because we need to change the combinator as soon as the number of composed functions does. Why not use variadic combinators instead?

```javascript
const comp = f => g => x => f(g(x));
const id = x => x;

const compn = (...fs) =>
  fs.reduce((acc, x) => comp(acc) (x), id);

const inc = x => x + 1;
const sqr = x => x * x;

compn(
  inc,
  inc,
  inc,
  inc,
  sqr) (5); // 29
```
[run code](https://repl.it/@scriptum/SpecializedWeepyVirus)

Or even a curried version:

```javascript
const compn = f =>
  Object.assign(g => compn(x => f(g(x))), {run: f});

const inc = x => x + 1;
const sqr = x => x * x;

compn(
  inc)
  (inc)
  (inc)
  (inc)
  (sqr).run(5); // 29
```
[run code](https://repl.it/@scriptum/OblongYellowishGame)

The problem is that you cannot give them a proper type using the common type systems available for Javascript, at least not without type coersions. You might argue that this does not matter for untyped Javascript, but I will not recommend code in this course which cannot be typed for later use.

### Why relying on arity-aware combinators in the first place?

We could easily build a variadic compostion function that fits all cases:

```javascript
const comp = f => g => x => f(g(x));
const id = x => x;

const sub = x => y => x - y;
const sub_ = y => x => x - y;
const repeat = s => n => s.repeat(n);

const compn = fs =>
  fs.reduce((f, g) => comp(f) (g), id);

const fs = [repeat("x"), sub(1), sub(2), sub(3), sub(4)]; // "xxx"

compn(fs) (5);
```
[run code](https://repl.it/@scriptum/HurtfulSandybrownWorkspace)

But what type would `fs` have? If we typed it as an array `A[]`, all functions would have to share the same type, `(_: number) => number` for instance. If we typed it as a tuple `[A, B]` we would have to define all possible tuple sizes. Knowing this simple arity aware composition functions seem to be the lesser of two evils.

### Infix combinators

There are two more combinator that come in handy to improve readability:

```javascript
const infix = (x, f, y) => f(x) (y);
const appr = (f, y) => x => f(x) (y);

const sub3 = appr(sub, 3);

infix(2, sub, 3); // -1
sub3(2); // -1
```
[run code](https://repl.it/@scriptum/VirtualLuxuriousStacks)

`infix` mimics the notation of the same name, which is usually reserved to built-in operators in Javascript. `appr` is similar to the `flip` combinator but takes advantage of Javascript's multi-argument feature.

### Prospect of other forms of flat compositions

Keeping the syntax of ordinary function composition flat is not even half of the deal. There are plenty of types of compositions to discover and we will introduce suitable combinators which enable a linear data flow within the respective chapters.

### Editor's note

If you enjoyed this chapter please ðŸŒŸ scriptum here on Github or share it on your preferred social media platform. If you found a mistake or inaccuracy or want to propose an improvement please file an issue/feature. Thank you.

[&lt; prev chapter](https://github.com/kongware/scriptum/blob/master/course/ch-006.md) | [TOC](https://github.com/kongware/scriptum#functional-programming-course-toc) | [next chapter &gt;](https://github.com/kongware/scriptum/blob/master/course/ch-008.md)
