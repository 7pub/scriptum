## Composing Effects with Monad Transformers

Composing effects in a monadic way is tricky but also extremely powerful. In this chapter we will dive deep into the subject. Hang in there!

### Monads do not compose in general

Some monads do compose in a mechanical way. Here is an example of an `Array`/`Option` monad composition:

```javascript
// union constructor

const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);

const match = (tx, o) =>
  o[tx.tag] (tx);

// OPTION

const Option = union("Option");

const None = Option("None", {});
const Some = some => Option(Some, {some});

// Monad

const optChain = mx => fm =>
  match(mx, {
    None: _ => None,
    Some: ({some: x}) => fm(x)
  });

// ARRAY

// Monad

const arrChain = mx => fm =>
  arrFold(acc => x =>
    arrAppend(acc) (fm(x))) ([]) (mx);

// auxiliary functions

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

const arrAppend = xs => ys =>
  xs.concat(ys);

// MAIN

const mmx = [Some(10), Some(20), Some(30)],
  mmy = [Some(1), Some(2), Some(3)],
  mmz = [Some(1), Some(2), Some(0)];

const main = arrChain(mmx) (mx =>
  optChain(mx) (x =>
    arrChain(mmy) (my =>
      optChain(my) (y =>
        y === 0
          ? []
          : [Some(x / y)]))));

const main2 = arrChain([None]) (mx =>
  optChain(mx) (x =>
    arrChain(mmy) (my =>
      optChain(my) (y =>
        y === 0
          ? []
          : [Some(x / y)]))));

const main3 = arrChain(mmx) (mx =>
  optChain(mx) (x =>
    arrChain(mmz) (mz =>
      optChain(mz) (z =>
        z === 0
          ? []
          : [Some(x / z)]))));

main; // [Some(10), Some(5), Some(3.33), Some(20), Some(10), Some(6.66), Some(30), Some(10), Some(5)]
main2; // []
main3; // [Some(10), Some(5), Some(20), Some(10), Some(30), Some(10)]
```
[run code](https://repl.it/@scriptum/UntimelyImpressionableComputerscience)

The array contains individual elements that may have a value (`Some(x)`) or not (`None`). In the latter case values are just omitted, because this wittnesses the non-deterministic behavior of arrays.

However, other monads either do not compose at all or yield unexpected results. Let us rearrange the order of both monads to demonstrate this:

```javascript
// MAIN

const mmx = Some([10,20,30]),
  mmy = Some([1,2,3]),
  mmz = Some([1,2,0]);

const main = optChain(mmx) (mx =>
  optChain(mmy) (my =>
    Some(arrChain(mx) (x =>
      arrChain(my) (y =>
        y === 0
          ? []
          : [x / y])))));

const main2 = optChain(None) (mx =>
  optChain(mmy) (my =>
    Some(arrChain(mx) (x =>
      arrChain(my) (y =>
        y === 0
          ? []
          : [x / y])))));

const main3 = optChain(mmx) (mx =>
  optChain(mmz) (mz =>
    Some(arrChain(mx) (x =>
      arrChain(mz) (z =>
        z === 0
          ? []
          : [x / z])))));

main; // Some([10, 5, 3.33, 20, 10, 6.66, 30, 15, 10])
main2; // None
main3; // Some([10, 5, 20, 10, 30, 15, 10])
```
[run code](https://repl.it/@scriptum/IncompatibleSlipperyOpengroup)

At first sight the results might seem appropriate, but `main3` actually exhibits unexpected behavior. `Option`'s semantics is quite simple: As soon as a single `None` value is created the entire computaion has to be short circuited and evaluates to `None`. Even though `main3` two arguments `mmx`/`mmz` are of type `Some` it yields `None`, because the monadic action returns a `None` when it reaches `0` within `mmz`. Consequenlty, the entire `main3` computation is supposed to evaluate to `None`. This unexpected behavior breaks the semantics of the type and is thus equivalent to an error. The monad instances of `Option`/`Array` do not compose in a mechanical way.

### Higher order monads to the rescue

Monads do not compose in general means we need to implement each and every composition which is specific to the involved monads. This is not particularly satisfying, because we probably wind up with writing a lot of repetetive code. The goal is to write a composable monad instance once and than compose it with any possible monad. In order to achieve this we need a monad that takes another monad to create a new one. What we need is a higher order monad. Let us implement such a higher order monad using the `Option` type:

### Monad transformer stacks

#### `OptionT`/`Array` stack

TODO

#### Illegal `ArrayT`/`Option` stack

Requires the base monad to be commutative:

```javascript
// union constructor

const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);

const match = (tx, o) =>
  o[tx.tag] (tx);

// OPTION

const Option = union("Option");

const None = Option("None", {});
const Some = some => Option(Some, {some});

// Functor

const optMap = f => tx =>
  match(tx, {
    None: _ => None,
    Some: ({some: x}) => Some(f(x))
  });

// Applicative

const optAp = tf => tx =>
  match(tf, {
    None: _ => None,
    Some: ({some: f}) => {
      return match(tx, {
        None: _ => None,
        Some: ({some: x}) => Some(f(x))
      });
    }
  });

const optOf = x => Some(x);

// Monad

const optChain = mx => fm =>
  match(mx, {
    None: _ => None,
    Some: ({some: x}) => fm(x)
  });

// Monad Transformer

const optChainT = ({chain, of}) => mmx => fmm =>
  chain(mmx) (mx =>
    match(mx, {
      None: _ => of(None),
      Some: ({some: x}) => fmm(x)
    }));

const optOfT = of => x => of(Some(x));

// ARRAY

// Monad

const arrChain = mx => fm =>
  arrFold(acc => x =>
    arrAppend(acc) (fm(x))) ([]) (mx);

const arrOf = x => [x];

// Monad Transformer

/*const arrChainT = ({chain, of}) => mmx => fmm =>
  chain(mmx) (mx =>
    of(arrFold(acc => x =>
      chain(fmm(x)) (my => arrAppend(acc) (my))) ([]) (mx)));*/

/*const arrChainT = ({chain, of}) => mmx => fmm => {
  const go = mmy => chain(mmy) (my =>
    arrFold(acc => y =>
      chain(fmm(y)) (mz => go(of(arrAppend(acc) (mz))))) ([]) (my));

  return go(mmx);
};*/

const arrChainT = ({map, ap, of ,chain}) => mmx => fmm =>
  chain(mmx) (mx => {
    const go = ([x, ...xs]) =>
      x === undefined
        ? of([])
        : ap(map(arrCons) (fmm(x))) (go(xs));

    return chain(go(mx)) (ys => of(arrFold(arrAppend) ([]) (ys)));
  });

const arrOfT = of => x => of([x]);

// Monad Stacks

const arrOptChainT = arrChainT(
  {map: optMap, ap: optAp, of: optOf, chain: optChain});

const arrOptOfT = arrOfT(optOf);

const optArrChainT = optChainT(
  {chain: arrChain, of: arrOf});

const optArrOfT = optOfT(arrOf);

// auxiliary functions

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

const arrAppend = xs => ys =>
  xs.concat(ys);

const arrCons = x => xs =>
  [x].concat(xs);

// MAIN
const mma = Some([10, 20, 30]);
const mmb = Some([1, 2, 3]);

const mmx = [Some(10), Some(20), Some(30)];
const mmy = [Some(1), Some(2), Some(3)];

/*const main =
  optArrChainT(mmx) (x => {
    return optArrChainT(mmy) (y => {
      return y === 0
        ? [None]
        : optArrOfT(x / y)})});*/

const main2 =
  arrOptChainT(mma) (x => {
    return arrOptChainT(mmb) (y => {
      return y === 0
        ? None
        : arrOptOfT(x / y)})});

//console.log(main);
console.log(main2);
```
[run code](https://repl.it/@scriptum/JumboTrickyActivecontent)

#### Lawful `ListT`/`Option` stack

```javascript
```
[run code](https://repl.it/@scriptum/OrganicWheatMisrac)

#### Add stack-safety to your transformer stack

```javascript
// union constructor

const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);

const match = (tx, o) =>
  o[tx.tag] (tx);

// TRAMPOLINE

const monadRec = step => {
    while (step.tag !== "Base")
      step = step.f(...step.args);

    return step.x;
};

const Base = x =>
  ({tag: "Base", x});

const Chain = f => (...args) =>
  ({tag: "Chain", f, args});

// Monad

const recChain = mx => fm =>
  mx.tag === "Chain"
    ? Chain(args => recChain(mx.f(...args)) (fm)) (mx.args)
    : fm(mx.x);

const recOf = Base;

// OPTION

const Option = union("Option");

const None = Option("None", {});

const Some = some => Option(Some, {some});

// Monad

const optChain = mx => fm =>
  match(mx, {
    None: _ => None,
    Some: ({some: x}) => fm(x)
  });

const optOf = x => Some(x);

// Monad Transformer

const optChainT = ({chain, of}) => mmx => fmm =>
  chain(mmx) (mx =>
    match(mx, {
      None: _ => of(None),
      Some: ({some: x}) => fmm(x)
    }));

const optOfT = of => x => of(Some(x));

// Monad Stack

const optRecChain = optChainT(
  {chain: recChain, of: recOf});

const optRecOf = optOfT(recOf);

// MAIN

const sum = xs => {
  const go =
    Chain((tx, i) =>
      i === xs.length
        ? tx
        : optRecChain(tx) (acc =>
            optRecChain(recOf(xs[i])) (x => go(optRecOf(acc + x), i + 1))));

  return go(optRecOf(0), 0);
};

const xs = Array(1e5).fill(Some(1)),
  ys = Array(1e5).fill(Some(1));

ys[1000] = None;

monadRec(sum(xs)); // Some(100000)
monadRec(sum(ys)); // None
```
[run code](https://repl.it/@scriptum/FrizzyWornFormulas)

### Transformer laws

### Generalizing `lift`

### Alternative approaches

#### Pre-composed monads

TODO

#### Continuation monad?

TODO

#### Outllok on more advanced alternatives

TODO

* monadic effect composition is under actice research
* monadic effect composition is hard
* the passed base monad is the outer monad, which is kind of non-intuitive
* lifting actions seems to be a big issue of transormers
* the outermost monad is called bottom?!?
* every monad has a transformer
* transformers are point-free style
* Alternatives:
  * custom monad
  * continuation monad
* the outer monad does not know anything about the monad it is transforming
* the innermost monad determines the dominant semantics of the stack
* the order of a stack determines its semantics
* the interaction of two effects can be controlled by picking a specific stack order
* Either(List):  Each branch can fail separately
* List(Either): The whole non-deterministic computation can fail with a single error
* a monad without a transformer must be at the bottom of the stack
* be carefulwith ListT https://wiki.haskell.org/ListT_done_right
* monad transformer laws
* polymorphic `lift` function
* you can always write your own hard-coded monad combination as a single custom monad
* the transformer is a function that transforms a base monad, which is thus the transormed monad
* even though a transformer are just two functions `chainT` and `ofT`, it is hard to generalize the composition of a single monad
* if you write a transformer you cannot reference to the corresponding `chain`/`of` operators, because from the perspective of the transformer theses functions doesn't exist
* Monad transformers need their own type wrapper
* not every monad is a transformer
* transformers are not commutative
