## Composing Effects with Monad Transformers

Composing effects in a monadic way is tricky but also extremely powerful. In this chapter we will delve deep into the subject. Hang in there!

### Monads do not compose in general

While there are some monads of different type that do compose in a mechanical way this does not apply in general. As soon as you nest different monadic types into one another you will eventually run into compositions that behave in unexpected ways or even raise errors:

```
// mmx has type M<N<A>>

chain1(mmx) (mx => // M layer
  chain2(mx) (x => // N layer
    ...));
```
The problem lies in joining the different effect layers `M` and `N` for every possible monad. I am not going to show examples, because that would mean a considerable effort and would rather confuse than help. At this point we just have to accept this as fact.

### Higher order monads to the rescue

What are the consequences that monads of different type do not compose in general? It means we need to implement each and every composition by hand, because it is specific to the set of involved monads. This is not particularly satisfying. We probably end up writing a lot of `chain` and `of` functions with large portions of repetitive code. The goal is to write a composable monad instance once and than compose it with any possible monad, so that we have a 1-1 relation between normal monad instances and our composbale monad implementations. In order to achieve this we need a monad that takes another monad to create a new one - in other words a higher order monad. But what exactly constitutes a higher order monad at the term level? Well, just `chain` and `of` which each take `chain` and `of` from another monad as their first argument.

The monad passed to the higher order one is called the base monad. If we compose two monads of different type we get back a nested monad, where the base monad becomes the inner and the higher order monad becomes the outer one:

```javascript
// HOM = Higher Order Monad
// BM  = Base Monad

ofHOM(ofBM) // yields
valueBM(valueHOM)

chainHOM(chainBM) // finally yields
valueBM(valueHOM)
```
The higher order monad transforms the inner monad by combining the effects. For this reason higher order monads are referred to as monad transformers.

### Monad transformer stacks

A monad transformer that takes a base monad returns a new monad, which in turn can be passed to another monad transformer. According to this principle we can compose several monads which figuratively speaking form a monad transformer stack. In the next sections we will build such a stack step by step:

#### `EffT`/`Array`

We start with a computation with two effects,

* a suspensory
* and non-deterministic effect

We use a `EffT` monad transformer that takes an `Array` monad to encode the composition:

```javascript
// record constructor

const record = (type, o) =>
  (o[type.name || type] = type.name || type, o);

// common combinators

const comp = f => g => x => f(g(x));

// EFFECT

const Eff = eff =>
  record(Eff, {get eff() {return eff()}});

// Monad

const effOf = x => Eff(() => x);

const effChain = mx => fm =>
  Eff(() => fm(mx.eff).eff);

// Monad Transformer

const effOfT = of => x => of(Eff(() => x));

const effChainT = ({map, chain, of}) => mmx => fmm =>
  chain(mmx) (mx =>
    Eff(() => map(my => my.eff) (fmm(mx.eff))));

const effLiftT = of => fm =>
  comp(of) (fm);

// ARRAY

// Functor

const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));

// Monad

const arrChain = mx => fm =>
  arrFold(acc => x =>
    arrAppend(acc) (fm(x))) ([]) (mx);

const arrOf = x => [x];

// auxiliary functions

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

const arrAppend = xs => ys =>
  xs.concat(ys);

// EFFT/ARRAY

// Monad

const arrEffChain = effChainT(
  {map: arrMap, chain: arrChain, of: arrOf});

const arrEffOf = effOfT(arrOf);

// auxiliary functions

const arrEffFilter = p => arrEffChain(mmx) (x =>
  p(x)
    ? [effOf(x)]
    : []);

const arrEffTake = n => xs =>
  Eff(() => {
    const go = i => acc => {
      if (acc.length === n || xs.length === i)
        return acc;

      else {
        const ys = xs[i].eff;

        return ys.length === 0
          ? go(i + 1) (acc)
          : go(i + 1) (acc.concat(ys));
      }
    };

    return go(0) ([]);
  });

// MAIN

const randomNum = Eff(
  () => (
    console.log("eval"),
    Math.round(Math.random() * 100)));

const mmx = [randomNum, randomNum, randomNum, randomNum, randomNum];

const main = arrEffTake(3)
  (arrEffFilter(x => (x & 1) === 0));

// no effects yet...

main.eff; // logs eval (x times) and yields up to three even random numbers
```
[run code](https://repl.it/@scriptum/DelayedMeekCache)


* we have to distinguish the pure and the impure realm of our program
* inside the pure realm we compose descriptions of effectful computations of structure `[Eff]`
* inside the impure realm we evaluate effectful computations of structure `[Number]`

#### `EffT`/`List`

```javascript
TODO
```
[run code](https://repl.it/@scriptum/SlateblueUncomfortableLifecycle)

#### `OptionT`/`EffT`/`List`

Please note that the transformer stack we are going to build in the following sections are not particularly useful. I want you to solely focus on the mechanics of the effect composition rather than on the question if a particularly transformer stack is useful in practice.

* [run code](https://repl.it/@scriptum/FelineLoyalCache)
* [run code](https://repl.it/@scriptum/ClumsyDullApplicationframework)
* [run code](https://repl.it/@scriptum/WarpedBeigeNumerators)
* [run code](https://repl.it/@scriptum/FrizzyWornFormulas)
* [run code](https://repl.it/@scriptum/JumboTrickyActivecontent)
* [run code](https://repl.it/@scriptum/OrganicWheatMisrac)
* [run code](https://repl.it/@scriptum/NutritiousRowdyWearables)
* [run code](https://repl.it/@scriptum/MoralAuthorizedComputergames)

#### `OptionT`/`EffT`/`ListT`/`Tramp`

* adding stack-safety to your monad

### Order matters

### Monad transformer type wrapper

### Explicit versus implicit lifting

### Alternative approaches

#### Pre-composed monads

* one transformer fits all effects style

TODO

#### Continuation monad encodings

TODO

#### Outlook on more advanced alternatives

TODO

* monadic effect composition is under actice research
* monadic effect composition is hard
* the passed base monad is the outer monad, which is kind of non-intuitive
* lifting actions seems to be a big issue of transormers
* the outermost monad is called bottom?!?
* every monad has a transformer
* transformers are point-free style
* Alternatives:
  * custom monad
  * continuation monad
* the outer monad does not know anything about the monad it is transforming
* the innermost monad determines the dominant semantics of the stack
* the order of a stack determines its semantics
* the interaction of two effects can be controlled by picking a specific stack order
* Either(List):  Each branch can fail separately
* List(Either): The whole non-deterministic computation can fail with a single error
* a monad without a transformer must be at the bottom of the stack
* be carefulwith ListT https://wiki.haskell.org/ListT_done_right
* monad transformer laws
* polymorphic `lift` function
* you can always write your own hard-coded monad combination as a single custom monad
* the transformer is a function that transforms a base monad, which is thus the transormed monad
* even though a transformer are just two functions `chainT` and `ofT`, it is hard to generalize the composition of a single monad
* if you write a transformer you cannot reference to the corresponding `chain`/`of` operators, because from the perspective of the transformer theses functions doesn't exist
* Monad transformers need their own type wrapper
* not every monad is a transformer
* transformers are not commutative
* distinguish between eager and lazy effects
* transformers are based on different principles (they exist for various reasons)
* they are tricky due to the fact that many transformers are based on different principles (or exist for different reasons)
