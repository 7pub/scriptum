## Composing Effects with Monad Transformers

### Monads do not compose in general

Some monads do compose and some do not:

```javascript
// union constructor

const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);

const match = (tx, o) =>
  o[tx.tag] (tx);

// OPTION

const Option = union("Option");

const None = Option("None", {});
const Some = some => Option(Some, {some});

// Monad

const optChain = mx => fm =>
  match(mx, {
    None: _ => None,
    Some: ({some: x}) => fm(x)
  });

// ARRAY

// Monad

const arrChain = mx => fm =>
  arrFold(acc => x =>
    arrAppend(acc) (fm(x))) ([]) (mx);

// auxiliary functions

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

const arrAppend = xs => ys =>
  (xs.push.apply(xs, ys), xs);

// MAIN

const mmx = [Some(10), Some(20), Some(30)],
  mmy = [Some(1), Some(2), Some(3)],
  mmz = [Some(1), Some(2), Some(0)];

const mma = Some([10,20,30]),
  mmb = Some([1,2,3]),
  mmc = Some([1,2,0]);

const main = arrChain(mmx) (mx =>
  optChain(mx) (x =>
    arrChain(mmy) (my =>
      optChain(my) (y =>
        y === 0
          ? []
          : [Some(x / y)]))));

const main2 = arrChain([None]) (mx =>
  optChain(mx) (x =>
    arrChain(mmy) (my =>
      optChain(my) (y =>
        y === 0
          ? []
          : [Some(x / y)]))));

const main3 = arrChain(mmx) (mx =>
  optChain(mx) (x =>
    arrChain(mmz) (mz =>
      optChain(mz) (z =>
        z === 0
          ? []
          : [Some(x / z)]))));

const main4 = optChain(mma) (ma =>
  optChain(mmb) (mb =>
    Some(arrChain(ma) (a =>
      arrChain(mb) (b =>
        b === 0
          ? []
          : [a / b])))));

const main5 = optChain(None) (ma =>
  optChain(mmb) (mb =>
    Some(arrChain(ma) (a =>
      arrChain(mb) (b =>
        b === 0
          ? []
          : [a / b])))));

const main6 = optChain(mma) (ma =>
  optChain(mmc) (mc =>
    Some(arrChain(ma) (a =>
      arrChain(mc) (c =>
        c === 0
          ? []
          : [a / c])))));

main; // [Some(10), Some(5), Some(3.33), Some(20), Some(10), Some(6.66), Some(30), Some(10), Some(5)]
main2; // []
main3; // [Some(10), Some(5), Some(20), Some(10), Some(30), Some(10)]
main4; // Some([10, 5, 3.33, 20, 10, 6.66, 30, 15, 10])
main5; // None
main6; // Some([10, 5, 20, 10, 30, 15, 10])
```
[run code](https://repl.it/@scriptum/UntimelyImpressionableComputerscience)

### Higher order monads to the rescue

Monads do not compose in general means we need to implement each and every composition which is specific to the involved monads. This is not particularly satisfying, because we probably wind up with writing a lot of repetetive code. The goal is to write a composable monad instance once and than compose it with any possible monad. In order to achieve this we need a monad that takes another monad to create a new one. What we need is a higher order monad. Let us implement such a higher order monad using the `Option` type:

### Monad transformer stacks

#### `OptionT`/`Array` stack

TODO

#### Illegal `ArrayT`/`Option` stack

Requires the base monad to be commutative:

```javascript
// union constructor

const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);

const match = (tx, o) =>
  o[tx.tag] (tx);

// OPTION

const Option = union("Option");

const None = Option("None", {});
const Some = some => Option(Some, {some});

// Functor

const optMap = f => tx =>
  match(tx, {
    None: _ => None,
    Some: ({some: x}) => Some(f(x))
  });

// Applicative

const optAp = tf => tx =>
  match(tf, {
    None: _ => None,
    Some: ({some: f}) => {
      return match(tx, {
        None: _ => None,
        Some: ({some: x}) => Some(f(x))
      });
    }
  });

const optOf = x => Some(x);

// Monad

const optChain = mx => fm =>
  match(mx, {
    None: _ => None,
    Some: ({some: x}) => fm(x)
  });

// Monad Transformer

const optChainT = ({chain, of}) => mmx => fmm =>
  chain(mmx) (mx =>
    match(mx, {
      None: _ => of(None),
      Some: ({some: x}) => fmm(x)
    }));

const optOfT = of => x => of(Some(x));

// ARRAY

// Monad

const arrChain = mx => fm =>
  arrFold(acc => x =>
    arrAppend(acc) (fm(x))) ([]) (mx);

const arrOf = x => [x];

// Monad Transformer

/*const arrChainT = ({chain, of}) => mmx => fmm =>
  chain(mmx) (mx =>
    of(arrFold(acc => x =>
      chain(fmm(x)) (my => arrAppend(acc) (my))) ([]) (mx)));*/

/*const arrChainT = ({chain, of}) => mmx => fmm => {
  const go = mmy => chain(mmy) (my =>
    arrFold(acc => y =>
      chain(fmm(y)) (mz => go(of(arrAppend(acc) (mz))))) ([]) (my));

  return go(mmx);
};*/

const arrChainT = ({map, ap, of ,chain}) => mmx => fmm =>
  chain(mmx) (mx => {
    const go = ([x, ...xs]) =>
      x === undefined
        ? of([])
        : ap(map(arrCons) (fmm(x))) (go(xs));

    return chain(go(mx)) (ys => of(arrFold(arrAppend) ([]) (ys)));
  });

const arrOfT = of => x => of([x]);

// Monad Stacks

const arrOptChainT = arrChainT(
  {map: optMap, ap: optAp, of: optOf, chain: optChain});

const arrOptOfT = arrOfT(optOf);

const optArrChainT = optChainT(
  {chain: arrChain, of: arrOf});

const optArrOfT = optOfT(arrOf);

// auxiliary functions

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

const arrAppend = xs => ys =>
  (xs.push.apply(xs, ys), xs);

const arrCons = x => xs =>
  (xs.unshift(x), xs);

// MAIN
const mma = Some([10, 20, 30]);
const mmb = Some([1, 2, 3]);

const mmx = [Some(10), Some(20), Some(30)];
const mmy = [Some(1), Some(2), Some(3)];

/*const main =
  optArrChainT(mmx) (x => {
    return optArrChainT(mmy) (y => {
      return y === 0
        ? [None]
        : optArrOfT(x / y)})});*/

const main2 =
  arrOptChainT(mma) (x => {
    return arrOptChainT(mmb) (y => {
      return y === 0
        ? None
        : arrOptOfT(x / y)})});

//console.log(main);
console.log(main2);
```
[run code](https://repl.it/@scriptum/JumboTrickyActivecontent)

#### Lawful `ListT`/`Option` stack

```javascript
```
[run code](https://repl.it/@scriptum/OrganicWheatMisrac)

#### Add stack-safety to your transformer stack

```javascript
// union constructor

const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);

const match = (tx, o) =>
  o[tx.tag] (tx);

// TRAMPOLINE

const monadRec = step => {
    while (step.tag !== "Base")
      step = step.f(...step.args);

    return step.x;
};

const Base = x =>
  ({tag: "Base", x});

const Chain = f => (...args) =>
  ({tag: "Chain", f, args});

// Monad

const recChain = mx => fm =>
  mx.tag === "Chain"
    ? Chain(args => recChain(mx.f(...args)) (fm)) (mx.args)
    : fm(mx.x);

const recOf = Base;

// OPTION

const Option = union("Option");

const None = Option("None", {});

const Some = some => Option(Some, {some});

// Monad

const optChain = mx => fm =>
  match(mx, {
    None: _ => None,
    Some: ({some: x}) => fm(x)
  });

const optOf = x => Some(x);

// Monad Transformer

const optChainT = ({chain, of}) => mmx => fmm =>
  chain(mmx) (mx =>
    match(mx, {
      None: _ => of(None),
      Some: ({some: x}) => fmm(x)
    }));

const optOfT = of => x => of(Some(x));

// Monad Stack

const optRecChain = optChainT(
  {chain: recChain, of: recOf});

const optRecOf = optOfT(recOf);

// MAIN

const sum = xs => {
  const go =
    Chain((tx, i) =>
      i === xs.length
        ? tx
        : optRecChain(tx) (acc =>
            optRecChain(recOf(xs[i])) (x => go(optRecOf(acc + x), i + 1))));

  return go(optRecOf(0), 0);
};

const xs = Array(1e5).fill(Some(1)),
  ys = Array(1e5).fill(Some(1));

ys[1000] = None;

monadRec(sum(xs)); // Some(100000)
monadRec(sum(ys)); // None
```
[run code](https://repl.it/@scriptum/FrizzyWornFormulas)

### Transformer laws

### Generalizing `lift`

### Alternative approaches

#### Pre-composed monads

TODO

#### Continuation monad?

TODO

#### Outllok on more advanced alternatives

TODO

* monadic effect composition is under actice research
* monadic effect composition is hard
* the passed base monad is the outer monad, which is kind of non-intuitive
* lifting actions seems to be a big issue of transormers
* the outermost monad is called bottom?!?
* every monad has a transformer
* transformers are point-free style
* Alternatives:
  * custom monad
  * continuation monad
* the outer monad does not know anything about the monad it is transforming
* the innermost monad determines the dominant semantics of the stack
* the order of a stack determines its semantics
* the interaction of two effects can be controlled by picking a specific stack order
* Either(List):  Each branch can fail separately
* List(Either): The whole non-deterministic computation can fail with a single error
* a monad without a transformer must be at the bottom of the stack
* be carefulwith ListT https://wiki.haskell.org/ListT_done_right
* monad transformer laws
* polymorphic `lift` function
* you can always write your own hard-coded monad combination as a single custom monad
* the transformer is a function that transforms a base monad, which is thus the transormed monad
* even though a transformer are just two functions `chainT` and `ofT`, it is hard to generalize the composition of a single monad
* if you write a transformer you cannot reference to the corresponding `chain`/`of` operators, because from the perspective of the transformer theses functions doesn't exist
* Monad transformers need their own type wrapper
* not every monad is a transformer
* transformers are not commutative
