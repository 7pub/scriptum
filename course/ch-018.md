## Composing Effects with Monad Transformers

Composing effects in a monadic way is tricky but also extremely powerful. In this chapter we will delve deep into the subject. Hang in there!

### Monads do not compose in general

While there are some monads of different type that do compose in a mechanical way this does not apply in general. As soon as you nest different monadic types into each other, you will eventually run into compositions that break the monadic semantics or raise an error right away:

```
// mmx has type M<N<A>>

chain1(mmx) (mx =>
  chain2(mx) (x =>
    ...));
```
I am not going to show any examples, because such an endeavor would be quite elaborate. When you finished this chapter you can easily figure it out yourself.

### Higher order monads to the rescue

Monads of different type do not compose in general means we need to implement each and every composition by hand, which is specific to the involved monads. This is not particularly satisfying, because we probably end up with writing a lot of repetetive code. The goal is to write a composable monad instance once and than compose it with any possible monad, so that we have a 1-1 relation between normal monad instances and our new composbale monad implementations. In order to achieve this we need a monad that takes another monad to create a new one, in other words a higher order monad. But what constitutes a higher order monad at the term level? Well, `chain` and `of` that simply expect another `chain` and `of` as its argument respectively.

The monad passed to the higher order one is called the base monad. If we compose two monads of different type we get back a nested monad, where one is the inner and one the outer monad. The base monad becomes the inner one and the higher order monad the outer one, which is a bit counterintuitive at first:

```javascript
// HOM = Higher Order Monad
// BM  = Base Monad

ofHOM(ofBM) // yields
valueBM(valueHOM)

chainHOM(chainBM) // finally yields
valueBM(valueHOM)

```
The higher order monad transforms the inner monad into a combined one with combined semantics. For this reason higher order monads are usually referred to as monad transformers.

### Monad transformer stacks

Nested monads do not form a stack structure, but this is the functional parlance when it comes to transformers. In the next sections we will implement transformer stacks and observe their combined effect behavior.

#### `OptionT`/`Array` stack

Let us start with a simple composition where `OptionT` is the monad transformer and `Array` the base monad. It is tempting to simply use `Option`'s chain in order to construct `OptionT`'s one, but unfortunately this is not allowed. Implementing a monad transformer means to construct brand new  `chain` and `of` functions that are specific to this transformer:

```javascript
// record/union constructor

const record = (type, o) =>
  (o[type.name || type] = type.name || type, o);

const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);
  
const match = (tx, o) =>
  o[tx.tag] (tx);
  
// OPTIONT

const Option = union("Option");

const None = Option("None", {});

const Some = some => Option(Some, {some});

// Monad Transformer

const optOfT = of => x => of(Some(x));

const optChainT = ({chain, of}) => mmx => fmm =>
  chain(mmx) (mx =>
    match(mx, {
      None: _ => of(None),
      Some: ({some: x}) => fmm(x)
    }));

// ARRAY

// Monad

const arrChain = mx => fm =>
  arrFold(acc => x =>
    arrAppend(acc) (fm(x))) ([]) (mx);

const arrOf = x => [x];

// Monad stack

const arrOptChain = optChainT(
  {chain: arrChain, of: arrOf});

const arrOptOf = optOfT(arrOf);

// auxiliary functions

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

const arrAppend = xs => ys =>
  xs.concat(ys);

// MAIN

const mmx = [Some(10), Some(20), Some(30)],
  mmy = [Some(1), Some(2), Some(3)],
  mmz = [Some(0), Some(2), Some(3)];

const main = arrOptChain(mmx) (x =>
  arrOptChain(mmy) (y =>
    y === 0
      ? []
      : [Some(x / y)]));

const main2 = arrOptChain(mmx) (x =>
  arrOptChain(mmz) (z =>
    z === 0
      ? []
      : [Some(x / z)]));
      
main;  // [Some(10), Some(5), Some(3.33), Some(20), Some(10), Some(6.66), Some(30), Some(15), Some(10)]
main2; // [          Some(5), Some(3.33),           Some(10), Some(6.66),           Some(15), Some(10)]
```
[run code](https://repl.it/@scriptum/WarpedBeigeNumerators)

When we combine the non-deterministic effect with computations that might not yield a result we get back a list of such computations. The non-determinism allows as to drop `None` results. Let us add asynchronicity to the monad stack:

```javascript
TODO
```
[run code](https://repl.it/@scriptum/ClumsyDullApplicationframework)

Let us add stack-safety to the monad stack:

```javascript
TODO
```
[run code](https://repl.it/@scriptum/FrizzyWornFormulas)

#### Illegal `ArrayT`/`Option` stack

Requires the base monad to be commutative:

```javascript
// union constructor

const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);

const match = (tx, o) =>
  o[tx.tag] (tx);

// OPTION

const Option = union("Option");

const None = Option("None", {});
const Some = some => Option(Some, {some});

// Functor

const optMap = f => tx =>
  match(tx, {
    None: _ => None,
    Some: ({some: x}) => Some(f(x))
  });

// Applicative

const optAp = tf => tx =>
  match(tf, {
    None: _ => None,
    Some: ({some: f}) => {
      return match(tx, {
        None: _ => None,
        Some: ({some: x}) => Some(f(x))
      });
    }
  });

const optOf = x => Some(x);

// Monad

const optChain = mx => fm =>
  match(mx, {
    None: _ => None,
    Some: ({some: x}) => fm(x)
  });

// Monad Transformer

const optChainT = ({chain, of}) => mmx => fmm =>
  chain(mmx) (mx =>
    match(mx, {
      None: _ => of(None),
      Some: ({some: x}) => fmm(x)
    }));

const optOfT = of => x => of(Some(x));

// ARRAY

// Monad

const arrChain = mx => fm =>
  arrFold(acc => x =>
    arrAppend(acc) (fm(x))) ([]) (mx);

const arrOf = x => [x];

// Monad Transformer

/*const arrChainT = ({chain, of}) => mmx => fmm =>
  chain(mmx) (mx =>
    of(arrFold(acc => x =>
      chain(fmm(x)) (my => arrAppend(acc) (my))) ([]) (mx)));*/

/*const arrChainT = ({chain, of}) => mmx => fmm => {
  const go = mmy => chain(mmy) (my =>
    arrFold(acc => y =>
      chain(fmm(y)) (mz => go(of(arrAppend(acc) (mz))))) ([]) (my));

  return go(mmx);
};*/

const arrChainT = ({map, ap, of ,chain}) => mmx => fmm =>
  chain(mmx) (mx => {
    const go = ([x, ...xs]) =>
      x === undefined
        ? of([])
        : ap(map(arrCons) (fmm(x))) (go(xs));

    return chain(go(mx)) (ys => of(arrFold(arrAppend) ([]) (ys)));
  });

const arrOfT = of => x => of([x]);

// Monad Stacks

const arrOptChainT = arrChainT(
  {map: optMap, ap: optAp, of: optOf, chain: optChain});

const arrOptOfT = arrOfT(optOf);

const optArrChainT = optChainT(
  {chain: arrChain, of: arrOf});

const optArrOfT = optOfT(arrOf);

// auxiliary functions

const arrFold = f => init => xs => {
  let acc = init;
  
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

const arrAppend = xs => ys =>
  xs.concat(ys);

const arrCons = x => xs =>
  [x].concat(xs);

// MAIN
const mma = Some([10, 20, 30]);
const mmb = Some([1, 2, 3]);

const mmx = [Some(10), Some(20), Some(30)];
const mmy = [Some(1), Some(2), Some(3)];

/*const main =
  optArrChainT(mmx) (x => {
    return optArrChainT(mmy) (y => {
      return y === 0
        ? [None]
        : optArrOfT(x / y)})});*/

const main2 =
  arrOptChainT(mma) (x => {
    return arrOptChainT(mmb) (y => {
      return y === 0
        ? None
        : arrOptOfT(x / y)})});

//console.log(main);
console.log(main2);
```
[run code](https://repl.it/@scriptum/JumboTrickyActivecontent)

#### Lawful `ListT`/`Option` stack

```javascript
```
[run code](https://repl.it/@scriptum/OrganicWheatMisrac)

### Monad transformer type wrapper

### Explicit versus implicit lifting

### Alternative approaches

#### Pre-composed monads

* one transformer fits all effects style

TODO

#### Continuation monad encodings

TODO

#### Outlook on more advanced alternatives

TODO

* monadic effect composition is under actice research
* monadic effect composition is hard
* the passed base monad is the outer monad, which is kind of non-intuitive
* lifting actions seems to be a big issue of transormers
* the outermost monad is called bottom?!?
* every monad has a transformer
* transformers are point-free style
* Alternatives:
  * custom monad
  * continuation monad
* the outer monad does not know anything about the monad it is transforming
* the innermost monad determines the dominant semantics of the stack
* the order of a stack determines its semantics
* the interaction of two effects can be controlled by picking a specific stack order
* Either(List):  Each branch can fail separately
* List(Either): The whole non-deterministic computation can fail with a single error
* a monad without a transformer must be at the bottom of the stack
* be carefulwith ListT https://wiki.haskell.org/ListT_done_right
* monad transformer laws
* polymorphic `lift` function
* you can always write your own hard-coded monad combination as a single custom monad
* the transformer is a function that transforms a base monad, which is thus the transormed monad
* even though a transformer are just two functions `chainT` and `ofT`, it is hard to generalize the composition of a single monad
* if you write a transformer you cannot reference to the corresponding `chain`/`of` operators, because from the perspective of the transformer theses functions doesn't exist
* Monad transformers need their own type wrapper
* not every monad is a transformer
* transformers are not commutative
