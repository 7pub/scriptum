## Algebraic Structures, Properties and Lambda Abstractions

**[Editor's note: this chapter is under edit]**

Functonal programming is based on a number of mathematical structures, properties and laws. Its strong foundation in math is actually the most fundemantal difference to other paradigms.

### What is an algebraic structure?

An algebraic structure in functional programming is a set of operations on data types and a set of properties/laws this operations must satisfy. The structure is called algebraic, because it comes from math or abstract algebra respectively. But why would we use algebraic structures in programming in the first place? Because they are far more general and predicatable than those structures human intuition usually comes up with.

### Which are the algebraic properties?

Here is an incomplete list of basic algebraic properties/laws that are required by various algebraic structures:

* Absorption
* Associativity
* Commutativity
* Distributivity
* Idempotency
* Identity
* Inverse
* Monotonicity
* Transitivity
* etc.

There are other more specific laws that only apply to a single algebra. Here at the example of applicative functor:

* Homomorphism
* Interchange
* Composition

In the following sections I am going to introduce the most important laws.

#### Associativity

Associativity determines that the order operations are evaluated in does not matter:

```
(x op y) op z = x op (y op z) // infix operator notation
f(f(x) (y)) (z) = f(x) (f(y) (y)) // prefix function notation
```
This is an extremely useful feature of the functional paradigm, because it enables the evaluation of operations out of their lexical order and thus in parallel, for instance. As you can read from the equation above only operators/functions that have the same type in both their operands/arguments and in their result can be associative.

The associative property must not be confused with operator associativity, though. Function composition on the one hand is associative. Please note that since Javascript does not have a composition operator I demonstrate the property using a function:

```javascript
const comp = f => g => x => f(g(x));
const sub = x => y => x - y;
const inc = x => x + 1;
const sqr = x => x * x;

comp(comp(sqr) (inc)) (sub(10)) (5); // 36
comp(sqr) (comp(inc) (sub(10))) (5); // 36
```
The composition operator on the other hand is left associative, at least this applies to Haskell and other functional languages. Hence `f ∘ g ∘ h` is parsed as `(f ∘ g) ∘ h`.

#### Commutativity

While associativity renders order irrelevant at the operation level, commutativity goes further and relaxes it at the operand level by allowing to swap operands:

```
x op y = y op x
f(x) (y) = f(y) (x)
```
The number of useful algebraic structures that respect the commutative property (e.g. addition, multiplication) is much smaller than those who are associative (subtraction, division, appending two arrays).

#### Idempotency

Idempotency relaxes the exactly-once to a at-least-once semantics:

```
f(x) = f(f(x))
```
Some operations are overall idempotent (add or remove an element in a set/map, round a number to a certain decimal place). Others are idempotent if one of the operands is the identity element (add a number to zero, multply a number with one).

Idempotency is mainly affacted by the presence of mutations and reassignments:

TODO

#### Identity

TODO

### Lawful and lawless lambda abstractions

TODO

### Why lambda abstractions matter

Lambda abstractions are useful for various reasons. Here is an incomplete list:

* code reuse

As functional programmers we always strive to find small, reusable functions to keep our code DRY. Instead of `lenAll`, for instance,

```javascript
const lenAll = xs =>
  xs.map(s => s.length);
  
lenAll(["f", "fo", "foo"]);
```

we reuse library functions:

```javascript
const map = f => xs =>
  xs.map(f);
  
const len = xs => xs.length;

map(len) (["f", "fo", "foo"]);
```
* reduce boilerplate

Every time we recognize recurring code patterns we try to abstract them as a function.

* handle state

Every function has arguments and a return value where we can store our program state. So instead of (re-)assigning a new value to a variable we call a function that creates its own scope and pass the new value as an argument. As soon as the function is finished it creates another state and returns it.

* replace statements with expressions

Expressions are first class citizens, hence we want them everywhere throughout our code:

```javascript
const app_ = x => f => f(x);

app_({tag: “foo”}) (({tag}) => {
  switch(tag) {
    case “foo”:
       return ...;

    case “bar”:
       return ...;

    default:
       return ...;
  }
});
```
Function as wrappers allow us to turn statements into first class expressions without losing the concise and familiar syntax.

* avoid explicit lambdas

Take a look at `compAll`:

```javascript
const compAll = fs => x =>
  fs.reduce((y, f) => f(y), x);
```
It abstracts from arbitrarily long function compositions. However, it feels like we stopped midway through the process:

```javascript
const compAll = fs
  reduce(comp) (id);

// library code

const id = x => x;

const comp = f => g => x =>
  f(g(x));

const reduce = f => acc => xs =>
  xs.reduce((acc, x) => f(acc) (x));
```
We successfully abstracted from a lambda - a higher-order abstraction so to speak. The resulting code is not only more succinct but also more declarative and easer to reason about, because we replaced an explicit lambda that produces a decent amount of syntactic noise with plain names.

* utilize partial application

Can we convert an operation like `x * y` into a more lazy and thus more flexible one?

```javascript
const map = f => xs =>
  xs.map(x => f(x));
  
const mul = x => y => x * y;

map(mul(10));
```
A functional abstraction that requires no algebraic laws at all is not lawless. It just has fewer mathematical properties you can rely on and consequently is less predictable and less resilient.

### The rule of the simplest abstraction

* map example

### Abstraction trade-off

* encode conditions as functions

***

OBSOLETE

### Lawless abstractions

Although lawless abstraction sounds like the fella you wanna hang out with they are harmful, as they obfuscate the intention of your code. What are the criteria that render an abstraction lawless?

* it has no type (applies only to untyped settings, of course)
* it resembles an algebraic structure but violates its laws

Please note that the last three points are merely soft facts, that is to say for instance, not every uncommon or unknown abstraction is an unprincipled one. However, the chance that it is an unprincipled one is much higher, because the odds that you have found a new useful, reusable abstraction that no one found before are rather small.

I will not show any examples, because such an endeavor would not be particularly helpful. This is just the attempt to sensitize you on the subject. The ability to recognize unprincipled or lawless abstractions is an ongoing process and separates advanced functional programmers from novices.

### The tradeoff of abstractions

The process of abstraction in programming is evolutionary and mainly depends on the skill level of the involved programmers. We can often add another level of abstraction to our code. While abstracting in general raises code quality, it also makes it harder for outsiders to comprehend your intentions. You should therefore always take another objective into account:

**Keep your code accessible**

This is a highly opinion-based statement, of course and, as I said before, mainly depends on the skill level of the team. The more skilled a team is the more abstractions it can conceive.

### Examples of reasonable abstractions

The first example demonstrates composition in the second argument of a curried function:

```javascript
const comp2nd = f => g => x => y =>
  f(x) (g(y));

const fold = f => init => xs =>
  xs.reduce((acc, x) => f(acc) (x), init);

const comp = f => g => x =>
  f(g(x));

const id = x => x;
const empty = [];

const foldMap = ({fold, append, empty}) => f =>
  fold(comp2nd(append) (f)) (empty);

foldComp = foldMap({fold, append: comp, empty: id});

foldComp(add) ([1, 2, 3]) (100); // 106
```
[run code](https://repl.it/@scriptum/CapitalRosyEntropy)

The second example shows composition in both arguments of a curried function:

```javascript
const compOn = f => g => x => y => f(g(x)) (g(y));

const sortBy = f => xs =>
  [...xs].sort((x, y) => f(x) (y));

const compare = x => y =>
  x < y ? -1
    : x > y ? 1
    : 0;

const fst = ([x, y]) => x;

sortBy(compOn(compare) (fst))
  ([[2, "world"], [4, "!"], [1, "hello"]]); // [[1, "hello"], [2, "world"], [4, "!"]]
```
[run code](https://repl.it/@scriptum/ThankfulMoralFiles)

### The harm of over-engineering

While it is a good intention to reduce the need of boolean based conditionals in your code, you should not try to encode conditional statements as functions:

```javascript
const ifElse = p => f => g => x => {
  if (p(x))
    return f(x);
   
  else
    return g(x);
}

ifElse(isEven) (doThis) (doThat) (2);
```
The example above may work with regard to the simple scenario. There are a million other slightly different ways to express conditional branching, especially if things get more complex. Abstracting from conditions this way quickly leads to a mess:

**Do never try to encode `if`/`else` or `switch` statements with specialized functions!**

However, in Javascript it makes a lot of sense to use function wrappers in order to turn conditional statements into first class expressions:

```javascript
const app_ = x => f => f(x);

const ifElse = app_; // function alias

ifElse(obj) (({foo, bar}) => {
  if (foo)
    return ...
    
  else if (bar)
    return ...
    
  else
    return ...
});
```
The former example of this section demonstrates the harm of over-engineering. There are numerous other ones. Recognizing the overuse of abstractions again separates the seasoned functional programmer from the novice. You will get there eventually, provided you keep on learning.

### Editor's note

If you enjoyed this chapter please 🌟 scriptum here on Github or share it on your preferred social media platform. If you found a mistake or inaccuracy or want to propose an improvement please file an issue/feature. Thank you.

[&lt; prev chapter](https://github.com/kongware/scriptum/blob/master/course/ch-003.md) | [TOC](https://github.com/kongware/scriptum#functional-programming-course-toc) | [next chapter &gt;](https://github.com/kongware/scriptum/blob/master/course/ch-005.md)
