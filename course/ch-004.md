## Algebraic Structures, Properties and Lambda Abstractions

**[Editor's note: this chapter is under edit]**

Functonal programming is based on a number of mathematical structures, properties and laws. Its strong foundation in math is actually the most fundemantal difference to other paradigms.

### What is an algebraic structure?

An algebraic structure in functional programming is a set of operations on data types and a set of properties/laws this operations must satisfy. The structure is called algebraic, because it comes from math or abstract algebra respectively. But why would we use algebraic structures in programming in the first place? Because they are far more general and predicatable than those structures human intuition usually comes up with.

### Which are the algebraic properties?

Here is an incomplete list of basic algebraic properties/laws that are required by various algebraic structures:

* Absorption
* Associativity
* Commutativity
* Distributivity
* Idempotency
* Identity
* Inverse
* Monotonicity
* Transitivity
* etc.

There are other more specific laws that only apply to a single algebra. Here at the example of applicative functor:

* Homomorphism
* Interchange
* Composition

In the following sections I am going to introduce the most important laws.

#### Associativity

Associativity determines that the order operations are evaluated in does not matter:

```
(x op y) op z = x op (y op z) // infix operator notation
f(f(x) (y)) (z) = f(x) (f(y) (y)) // prefix function notation
```
This is an extremely useful feature of the functional paradigm, because it enables the evaluation of operations out of their lexical order and thus in parallel, for instance. As you can read from the equation above only operators/functions that have the same type in both their operands/arguments and in their result can be associative.

The associative property must not be confused with operator associativity, though. Function composition on the one hand is associative. Please note that since Javascript does not have a composition operator I demonstrate the property using a function:

```javascript
const comp = f => g => x => f(g(x));
const sub = x => y => x - y;
const inc = x => x + 1;
const sqr = x => x * x;

comp(comp(sqr) (inc)) (sub(10)) (5); // 36
comp(sqr) (comp(inc) (sub(10))) (5); // 36
```
The composition operator on the other hand is left associative, at least this applies to Haskell and other functional languages. Hence `f ∘ g ∘ h` is parsed as `(f ∘ g) ∘ h`.

#### Commutativity

While associativity renders order irrelevant at the operation level, commutativity goes further and relaxes it at the operand level by allowing to swap operands:

```
x op y = y op x
f(x) (y) = f(y) (x)
```
The number of useful algebraic structures that respect the commutative property (e.g. addition, multiplication) is much smaller than those who are associative (subtraction, division, appending two arrays).

#### Idempotency

Idempotency relaxes the exactly-once to a at-least-once semantics:

```
f(x) = f(f(x))
```
Some operations are overall idempotent (add or remove an element in a set/map, round a number to a certain decimal place). Others are idempotent if one of the operands is the identity element (add a number to zero, multply a number with one).

Idempotency is mainly affacted by the presence of mutations and reassignments. Please note that I use a more relaxed form of idempotency to demonstrate this:

```javascript
const cons = x => xs =>
  [x].concat(xs);
  
const cons_ = x => xs =>
  (xs.unshift(x), xs);

const xs = [2, 3],
  ys = [2, 3];

cons(1) (xs); // [1, 2, 3]
cons(1) (xs); // [1, 2, 3]
cons_(1) (ys); // [1, 2, 3]
cons_(1) (ys); // [1, 1, 2, 3]
```
#### Identity

When talking about identity we need to distinguish identity elements and identity functions. Identity elements are those elements within an operation that preserve the identity of the other operands/arguments. Here are a few examples:

```javascript
add(2) (0) === 2;
//      ^
mul(2) (1) === 2;
//      ^
concat("foo") ("") === "foo";
//             ^^
concat([1, 2]) ([]) === [1, 2];
//              ^^
all(true) (true) === true;
//         ^^^^
any(true) (false) === true;
//         ^^^^^
compare(LT) (EQ) === LT;
//           ^^
compare(GT) (EQ) === EQ;
//           ^^
```
The identity function preserves the identity of its argument:

```javascript
const id = x => x;
const map = f => xs => xs.map(f);

id(123) === 123;
id("foo") === "foo";
map(id) ([1, 2, 3]) === [1, 2, 3];
```
There are many others. It is hard to explain why identity is a useful property like it is hard to explain the purpose of `0`. If you stick to functional programming you will come across various situations where identity is necessary.

### Lawless abstractions

First of all, most abstractions in the functional paradigm are function encodings. Exceptions like pattern matching or do-notation do confirm this rule. A lawful lambda abstraction has to abide by algebraic properties. If we ignore dependently typed languages no current type system is sophisticated enough to enforce these laws. It is just a convention. However, not every abstraction requires algebraic laws. You might consider such an abstraction less significant or elegant, but it can still be useful. In order to be lawless an abstraction must meet one of the following criteria:

* it has no type (applies only to untyped settings, of course)
* it resembles an algebraic structure but violates its laws

Although lawless abstraction sounds like the fella you wanna hang out with, they are harmful as they obfuscate the intention of your code.

### Why lambda abstractions matter

Lambda abstractions are useful for various reasons. Here is an incomplete list:

#### Code reuse

As functional programmers we always strive to find small, reusable functions to keep our code DRY. Instead of writing a bunch of sorting function we write a single one that takes the order as an argument: 

```javascript
const sortBy = comparator => xs =>
  xs.sort((x, y) => comparator(x) (y));

const flip = f => y => x => f(x) (y);

const compOn = f => g => x => y =>
  f(g(x)) (g(y));

const fst = ([x, y]) => x;

const asc = x => y =>
  x < y ? -1
    : x > y ? 1
    : 0;

const desc = flip(asc);

sortBy(asc)
  ([2, 9, 5, 0, 1, 6, 4, 8, 3, 7]); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  
sortBy(desc)
  ([2, 9, 5, 0, 1, 6, 4, 8, 3, 7]); // [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

sortBy(compOn(asc) (fst))
  ([[2, "world"], [3, "!"], [1, "hello"]]); // [[1, "hello"], [2, "world"], [3, "!"]]

sortBy(compOn(desc) (fst))
  ([[2, "world"], [3, "!"], [1, "hello"]]); // [[3, "!"], [2, "world"], [1, "hello"]]
```
[run code](https://repl.it/@scriptum/FakeImperturbableFinance)

#### Reduce boilerplate

If we recognize a great amount of simple, verbose and recurring code,

```javascript
const Option = "Some";
const Some = some => ({type: "Option", tag: "Some", some});
const None = some => ({type: "Option", tag: "None"});

const head = xs =>
  xs.length === 0
    ? None
    : Some(xs[0]);

// library code ^^^

const xs = [5, 7, 9],
  tx = head(xs);
  
let x;

switch (tx.tag) {
  case "Some":
    x = tx.some;
    break;
  
  case "None":
    x = 0;
    break;
}

// 11 LOC
```
we try to abstract from it with functions:

```javascript
const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);

const match = (tx, o) =>
  o[tx.tag] (tx);

const Option = union("Option");
const None = Option("None", {});
const Some = some => Option(Some, {some});

const head = xs =>
  xs.length === 0
    ? None
    : Some(xs[0]);

// library code ^^^

const xs = [5, 7, 9];

const x = match(head(xs), {
  Some: ({some}) => some,
  None: _ => 0
});

// 5 LOC
```
#### Handle state

Instead of holding state in `const` or mutable state in `let` assignments, we hold it in the function call stack:

```javascript
const arrScan = f => x => xs => {
  const go = (y, i) =>
    xs.length === i
      ? [y]
      : [y, ...go(f(y) (xs[i]), i + 1)];
  
  return go(x, 0);
};

arrScan(
  x => y => x + y) (0)
    ([1, 2, 3, 4, 5]); // [0, 1, 3, 6, 10, 15]
```
[run code](https://repl.it/@scriptum/PrestigiousDisguisedKeyboard)

Although we track a lot of state in the example above only a single assignment for the auxiliary function is used. Everything else is held in the call stack. This idea scales and if you are concerned about stack overflow I will introduce trampolines in another chapter.

#### Replace statements with expressions

Expressions are first class citizens, hence we want them everywhere throughout our code:

```javascript
const app_ = x => f => f(x);

app_({tag: “foo”}) (({tag}) => {
  switch(tag) {
    case “foo”:
       return ...;

    case “bar”:
       return ...;

    default:
       return ...;
  }
});
```
Function as wrappers allow us to turn statements into first class expressions without losing the concise and familiar syntax.

#### Avoid explicit lambdas

Take a look at `compAll`:

```javascript
const compAll = fs => x =>
  fs.reduce((y, f) => f(y), x);
```
It abstracts from arbitrarily long function compositions. However, it feels like we stopped midway through the process:

```javascript
const compAll = fs
  reduce(comp) (id);

// library code

const id = x => x;

const comp = f => g => x =>
  f(g(x));

const reduce = f => acc => xs =>
  xs.reduce((acc, x) => f(acc) (x));
```
We successfully abstracted from a lambda - a higher-order abstraction so to speak. The resulting code is not only more succinct but also more declarative and easer to reason about, because we replaced an explicit lambda that produces a decent amount of syntactic noise with plain names.

#### Utilize partial application

Can we convert an operation like `x * y` into a more lazy and thus more flexible one?

```javascript
const map = f => xs =>
  xs.map(x => f(x));
  
const mul = x => y => x * y;

map(mul(10));
```
A functional abstraction that requires no algebraic laws at all is not lawless. It just has fewer mathematical properties you can rely on and consequently is less predictable and less resilient.

### The rule of the simplest abstraction

* map example

```javascript
const map = f => xs =>
  xs.map(f);
  
const len = xs => xs.length;

map(len) (["f", "fo", "foo"]);
```
### Abstraction trade-off

* encode conditions as functions

The process of abstraction in programming is evolutionary and mainly depends on the skill level of the involved programmers. We can often add another level of abstraction to our code. While abstracting in general raises code quality, it also makes it harder for outsiders to comprehend your intentions. You should therefore always take another objective into account: Keep your code accessible

This is a highly opinion-based statement, of course and, as I said before, mainly depends on the skill level of the team. The more skilled a team is the more abstractions it can conceive.

***

OBSOLETE

### The harm of over-engineering

While it is a good intention to reduce the need of boolean based conditionals in your code, you should not try to encode conditional statements as functions:

```javascript
const ifElse = p => f => g => x => {
  if (p(x))
    return f(x);
   
  else
    return g(x);
}

ifElse(isEven) (doThis) (doThat) (2);
```
The example above may work with regard to the simple scenario. There are a million other slightly different ways to express conditional branching, especially if things get more complex. Abstracting from conditions this way quickly leads to a mess:

**Do never try to encode `if`/`else` or `switch` statements with specialized functions!**

However, in Javascript it makes a lot of sense to use function wrappers in order to turn conditional statements into first class expressions:

```javascript
const app_ = x => f => f(x);

const ifElse = app_; // function alias

ifElse(obj) (({foo, bar}) => {
  if (foo)
    return ...
    
  else if (bar)
    return ...
    
  else
    return ...
});
```
The former example of this section demonstrates the harm of over-engineering. There are numerous other ones. Recognizing the overuse of abstractions again separates the seasoned functional programmer from the novice. You will get there eventually, provided you keep on learning.

### Editor's note

If you enjoyed this chapter please 🌟 scriptum here on Github or share it on your preferred social media platform. If you found a mistake or inaccuracy or want to propose an improvement please file an issue/feature. Thank you.

[&lt; prev chapter](https://github.com/kongware/scriptum/blob/master/course/ch-003.md) | [TOC](https://github.com/kongware/scriptum#functional-programming-course-toc) | [next chapter &gt;](https://github.com/kongware/scriptum/blob/master/course/ch-005.md)
