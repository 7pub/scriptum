## Data Source Abstraction and Loop Fusion with Transducers

A transducer is nothing more than a pure higher order function that takes a binary function `append`, an accumulator `acc` and an arbitrary value `x` and appends `acc` to `x`. The transducer does not know anything about the data its argument `x` depends on, but it knows the structure of its output. Here is the identity transducer to illustrate the essence of the concept:

```javascript
append => acc => x => append(acc) (x)
append => x => acc => append(x) (acc)
```
Since appending two values is a non-associative operation there is a left and right associative version. This is merely a highly general description though. The following chapters will hopefully shed some light on the concept and its use cases.

### Loop fusion

The identity transducer does nothing else than behaving like a transducer. In order to do something useful a transducer must take an additional argument and do something useful with it. Here are the map and filter transducers:

```javascript
const map = f => append => acc => x =>
  append(acc) (f(x));

const filter = p => append => acc => x =>
  p(x)
    ? append(acc) (x)
    : acc;
```
In the following example we apply a composed transducer consisting of `map` and `filter` to take all words with an even length from an array and square their length:

```javascript
const map = f => append => acc => x =>
  append(acc) (f(x));

const filter = p => append => acc => x =>
  p(x)
    ? append(acc) (x)
    : acc;

const transduce = ({append, fold}) => f =>
  fold(f(append));

const comp = f => g => x => f(g(x));

const log = x => (console.log(x), x);

const arrFold = f => acc => xs => {
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return log(acc); // test log
};

const arrSnoc_ = xs => x =>
  (xs.push(x), xs);

const getLen = xs => xs.length;

const sqr = x => x * x;

const sqrLen = comp(sqr) (getLen);

const isEven = x => (x & 1) === 0;

const xs = ["f", "fo", "foo", "fooo", "foooo", "fooooo"];

main = transduce(
  {append: arrSnoc_, fold: arrFold})
    (comp(map(sqrLen))
      (filter(isEven)))
        ([]);

main(xs); // logs [4, 16, 36] once
```
[run code](https://repl.it/repls/StudiousVainInstance)

Although two distinct transducers are involved we only need to traverse the array once. The loops are fused by the composition. But how does this exactly work? When we look at the composition function we see that `f` and `g` are meant to be unary functions. However, the partially applied `map(sqrLen)` and `filter(isEven)` both expect three further arguments:

```javascript
const comp = f => g => x => f(g(x));

append => acc => x => ... // partially applied map

append => acc => x => ... // partially applied filter
```
The trick to understand transducers is to realize that if `x` of `comp` is not a normal value but also function and `f`/`g` of `comp` are not unary functions but n-ary ones, then `x` is passed to `g` as a function argument and hence `g` is a higher order function. When `g` is applied to `x` it itself returns another function that is passed to `f`.

With transducers `x` is `arrSnoc_` and `f` and `g` are the partially applied `map` and `filter`. Hence `append` of `filter` is applied to `arrSnoc_`, the resulting partially applied function is applied to `append` of `map` and thre resulting partially applied function is in turn returned to the caller:

```javascript
const comp = f => g => x => f(g(x)); // applied to map(sqrLen)

g => x => map(sqrLen) (g(x)); // applied to filter(isEven)

x => map(sqrLen) (filter(isEven) (x)); // function inlining

x => (append => acc => x => /*body of map*/) ((append => acc => x => /*body of filter*/) (x)); // applied to arrSnoc_

(append => acc => x => /*body of map*/) ((append => acc => x => /*body of filter*/) (arrSnoc_)); // reduce the inner application

(append => acc => x => /*body of map*/) (acc => x => /*body of filter*/); // reduce the inner application

acc => x => /*body of map*/; // return value
```
Phew! Now when we pass `acc` and `x` to the result function we actually pass them to the partially applied `map`, that is transducers compose from left to right as opposed to ordinary function composition. Another feature of transducers is that we have to pass the append function and the accumulator only once no matter how many transducers are involved in the composition.

Maybe you have noticed that in the example above `map` takes the function composition `sqrLen`. Since `map` is itself part of a composition you can think of it as a higher order composition. Compositions that take other compositions as its argument - this is the spirit of functional programming.

### Dynamic loop fusion

So far we had a setting where we could compose transducers upfront. Can we also apply the technique dynamically?

### Abstracting from data sources

### Break out of the Iteration

### Transduce infinite data structures
