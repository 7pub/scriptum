## Loop Fusion and Data Source Abstraction with Transducers

A transducer is just a pure higher order function that takes a binary function `append`, an accumulator `acc` and an arbitrary value `x` and appends `acc` to `x`. It does neither know anything about the data structure of its input `x` nor about the structure of its output. Since appending is a non-associtaive operation there is a left and a right associative operation. Here is the identity transducer to illustrate the essence of the concept:

```javascript
append => acc => x => append(acc) (x) // left associative
append => x => acc => append(x) (acc) // right associative
```
Transducers are intended for being feeded to fold functions so that they can be applied to each element of a `Foldable` data structure. The following chapters will hopefully shed some light on the concept and its use cases.

### Loop fusion

The identity transducer does does not change its input in any way. In order to do something useful a transducer must take an additional argument and do something useful with it. Here are the map and filter transducers:

```javascript
const map = f => append => acc => x =>
  append(acc) (f(x));

const filter = p => append => acc => x =>
  p(x)
    ? append(acc) (x)
    : acc;
```
In the following example we apply a composed transducer consisting of `map` and `filter` to take all words with an even length from an array and square their length:

```javascript
const map = f => append => acc => x =>
  append(acc) (f(x));

const filter = p => append => acc => x =>
  p(x)
    ? append(acc) (x)
    : acc;

const transduce = ({append, fold}) => f =>
  fold(f(append));

const comp = f => g => x => f(g(x));

const log = x => (console.log(x), x);

const arrFold = f => acc => xs => {
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return log(acc); // test log
};

const arrSnoc_ = xs => x =>
  (xs.push(x), xs);

const getLen = xs => xs.length;

const sqr = x => x * x;

const sqrLen = comp(sqr) (getLen);

const isEven = x => (x & 1) === 0;

const xs = ["f", "fo", "foo", "fooo", "foooo", "fooooo"];

main = transduce(
  {append: arrSnoc_, fold: arrFold})
    (comp(map(sqrLen))
      (filter(isEven)))
        ([]);

main(xs); // logs [4, 16, 36] once
```
[run code](https://repl.it/repls/StudiousVainInstance)

Although two distinct transducers are involved we only need to traverse the array once. Instead of passing each array element to one transducer after another they are passed to the transducer composition, which can include an arbitrary number of transducers. The composition fuses the loops so to speak. But how does this exactly work? When we look at `comp` we see that `f` and `g` are meant to be unary functions. However, the partially applied `map(sqrLen)` and `filter(isEven)` both expect three further arguments:

```javascript
const comp = f => g => x => f(g(x));

append => acc => x => ... // partially applied map

append => acc => x => ... // partially applied filter
```
The trick to understand transducers is to realize that if `x` of `comp` is not a normal value but also function and `f`/`g` of `comp` are not unary functions but n-ary ones, then `x` is passed to `g` as a function argument and hence `g` is a higher order function. When `g` is applied to `x` it itself returns another function that is passed to `f`.

With transducers `x` is `arrSnoc_` and `f` and `g` are the partially applied `map` and `filter`. Hence `append` of `filter` is applied to `arrSnoc_`, the resulting partially applied function is applied to `append` of `map` and thre resulting partially applied function is in turn returned to the caller:

```javascript
const comp = f => g => x => f(g(x)); // apply to map(sqrLen)

g => x => map(sqrLen) (g(x)); // apply to filter(isEven)

x => map(sqrLen) (filter(isEven) (x)); // function inlining

x => (append => acc => x => /*body of map*/) ((append => acc => x => /*body of filter*/) (x)); // apply to arrSnoc_

(append => acc => x => /*body of map*/) ((append => acc => x => /*body of filter*/) (arrSnoc_)); // reduce the inner application

(append => acc => x => /*body of map*/) (acc => x => /*body of filter*/); // reduce the application

acc => x => /*body of map*/; // return value
```
Phew! Now when we pass `acc` and `x` to the result function we actually pass them to the partially applied `map`, that is transducers compose from left to right as opposed to ordinary function composition. Another feature of transducers is that we have to pass the append function and the accumulator only once no matter how many transducers are involved.

Maybe you have noticed that in the example above `map` takes the function composition `sqrLen`. Since `map` is itself part of a composition you can think of it as a higher order composition. Compositions that take other compositions as its arguments - this is the spirit of functional programming.

### Abstracting from data sources

Another trait of transducers is their ability to abstract from data sources. A transducer only deals with a single value at a time. It does neither know anything about the underlying structure nor in what order values are pulled out of this structure. As a consequence we can apply our each transducer to each data structures that is at least `Foldable`, i.e. there exists a corresponding fold function:

```javascript
const List = union("List");

const Nil = List("Nil", {});

const Cons = head => tail =>
  List(Cons, {head, tail});

const cons_ = tail => head =>
  List(Cons, {head, tail});

const listMap = f =>
  rec(xs =>
    match(xs, {
      Nil: _ => Base(Nil),
      Cons: ({head, tail}) => Call(Cons(f(head)), Step(tail))
    }));

const listFold = f => acc => xs =>
  tailRec((acc_, xs) =>
    match(xs, {
      Nil: _ => Base(acc_),
      Cons: ({head, tail}) => Step(f(acc_) (head), tail)
    })) (acc, xs);

const sqr = x => x * x;

const isEven = x => (x & 1) === 0;

const main = transduce({append: cons_, fold: listFold})
  (comp(map(sqr))
    (filter(isEven)));

const tx = Cons(1) (Cons(2) (Cons(3) (Cons(4) (Cons(5) (Nil)))));

main(Nil) (tx); // {head: 16, tail: {head: 4, tail: Nil}}
```
[run code](https://repl.it/repls/DelayedUncomfortableEvaluation)

This time our initial transducer composition takes a linked list of numbers, filters all even numbers and squares them. We succeeded in abstracting from the data source.

However, somehow the order of the resulting list is inverted. Do you recall that appending is a non-associative operation? The inverted list witnesses this claim. It is just so that a left-associative fold of a linked list always inverts the order of that list. The only way to prevent consists in using a right fold alogn with right associative transducers:

```javascript
const mapr = f => append => x => acc =>
  append(f(x)) (acc);

const filterr = p => append => x => acc =>
  p(x)
    ? append(x) (acc)
    : acc;

const listFoldr = f => acc =>
  rec(xs =>
    match(xs, {
      Nil: _ => Base(acc),
      Cons: ({head, tail}) => Call(f(head), Step(tail))
    }));

const main = transduce({append: Cons, fold: listFoldr})
  (comp(mapr(sqr))
    (filterr(isEven)));

const tx = Cons(1) (Cons(2) (Cons(3) (Cons(4) (Cons(5) (Nil)))));

main(Nil) (tx); // {head: 4, tail: {head: 16, tail: Nil}}
```
[run code](https://repl.it/repls/PolishedPeruArraylist)

### Break out of the iteration

There are to ways to prematurely break out of a fold:

* use a lzay right associative one
* utilize local continuation passing style

In this chapter we will take a closer look at the latter approach. CPS requires all involved functions to have a continuation defined as their last formal parameter. Local just means that this requirement is contained within the directy involved functions and does not affect functions inside the global scope.

With transducers the fold and append function and the composed transducers themselves need to be defined in CPS:

```javascript
const mapk = f => append => acc => x =>
  Cont(k =>
    append(acc) (f(x)).cont(k));

const takek = n => append => { 
  let m = 0;

  return acc => x =>
    Cont(k =>
      m < n
        ? (m++, append(acc) (x).cont(k))
        : Base(acc))};

const record = (type, o) =>
  (o[type.name || type] = type.name || type, o);
  
const Cont = cont =>
  record("Cont", {cont});

const arrFoldk = f => acc => xs =>
  tailRec((acc_, i) =>
    i === xs.length
      ? Base(acc_)
      : f(acc_) (log(xs[i]), i).cont(acc__ => Step(acc__, i + 1))) (acc, 0);

const fix = f => x => f(fix(f)) (x);

const appr = (f, y) => x => f(x) (y);

const _let = f => f();

const calcBits = n =>
  Math.round(Math.log(n) / Math.log(2));

const xs = [32, 64, 4096, 65536, 16777216, 2147483648];

const main = transduce(
  {append: arrSnoc_, fold: arrFoldk})
    (comp(mapk(calcBits))
      (takek(3)))
        ([]);

main(xs); // logs 32, 64, 4096 and 65536 and yields [5, 6, 12]
```
[run code](https://repl.it/repls/TameSphericalClients)

As you can see the algorithm prematurely breaks out of the iteration as soon as the required number of array elements are processed. We will learn more about how to transform function in continuation passing style and use cases for CPS in a subsequent chapter of this course.
