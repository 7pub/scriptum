## A Little Type Theory

### Values and types

Every programming language has values and every value has a type. Please note that I will use Typescript notation to denote types:

```javascript
undefined // undefined

null // null

true // boolean

123 // number

[1, 2, 3] // number[]

new Set(["abc"]) // Set<string>

{foo: [1, 2, 3]} // {foo: number[]}

const map = f => xs => xs.map(f); // omitting the type for now
const len = xs => xs.length; // omitting the type for now

map(len) (["b", "ba", "bar"]) // <string, number>(f: (x: string) => number) => (xs: string[]) => number[]
```
A type can be inhabited by either no value at all (`undefined`), one value (`null`) or any number of values. Since `undefined` indicates a type error in Javascript, we pretend it has no value.

### Value and type constructors

A value constructor takes zero or more values and returns a new value. It lives at the term level of the language. In Javascript there is no difference between a value constructor and a normal function. However, in other more advanced functional languages there are. A value constructor that takes no arguments is just a typed constant.

A type constructor takes zero or more types and returns a new type. It lives at the type level of the language. Since Javascipt has no compile time there is no type level and no proper type constructors. The differentiation is still useful since it allows a better understanding of type systems in general. A type constructor that takes no types is just a ordinary type itself. In the following example value constructors with increasing complexity along with their types denoted in Typescript are listed. Later in this chapter we will see a data declaration involving type and several value constructors.

```javascript
// built-in value constuctors

null // null

true // boolean

fasle // boolean

Array // <A>(...args: A[]) => A[]

Set // <A>(arg: Iterable<A>) => Set<A>

// custom value constructors

const Foo = xs => ({foo: xs});

Foo // <A>(xs: A[]) => {foo: A[]}

class Pair extends Array { // ommitting the type for now
  constructor(x, y) {
    const r = super(2);
    r[0] = x;
    r[1] = y;
    return r;
  }
}

Pair // Pair<A, B>(x: A, y: B) => Pair<A, B>
```
`null` is a nullary value constructor and thus a typed constant. The type is only inhabited by a single value. `true`/`false` are also typed constants but their type `boolean` is inhabited by two values.

In Javascript the only way to create custom types is to declare a new `Object` type, either by using object factories (`Foo`) or by subclassing (`Pair`).

If a value constructor takes more than one value, the associated type is a product type:

```javascript
class Pair<A, B> extends Array {
  constructor(x: A, y: B) {
    const r: [A, B] = super(2);
    r[0] = x;
    r[1] = y;
    return r;
  }
}
```
 If a type constructor is associated with more than one value constructor, the underlying type is a sum type:
 
```javascript
const True = {tag: "True"} as const
const False = {tag: "False"} as const;

type Bool = typeof True | typeof False; // two value constructors
```
 This is the promised type declaration with a type and two value constructors. Since we use Typescript we can actually distinguish between both constructor kinds. `Bool` is a nullary type constructor, i.e. just a type. `True` and `False` are nullary value constructors, i.e. typed constants. Unfortunately it is not possible in Typescript to declare nullary constructors with implicit bracktes. We can merely declare new object types, hence the verbose workaround.

Another type declaration of a functional linked list comprising an unary type constructor, a nullary and an unary value constructor. Additionally it is a recursive type definition, becaue `List<A>` occurs inside `Cons`:

```javascript
const Nil = {tag: "Nil"} as const
const Cons = <A>(head: A) => (tail: List<A>) => ({tag: "Cons", head, tail} as const);

type List<A> = typeof Nil | typeof Cons; // two value constructors
```
### Higher order type constructors

Just as functions can take other functions as arguments on the term level, type constructors can take other type constructors as parameters on the type level. In type theory lingo this is also referred to as higher-kinded types. Such higher order type constructors cannot be expressed in Typescript directly. In the second part of this course, which engages in typed functional programming, I will introduce an alternative and greatly simplified technqiue to express higher-kinded types with the means of Typescript.

Taking the type from the last example `List<A>` we can convert it into a higher-kinded one by abstracting from the `List` part by declaring `T<A>`. We successfully abstracted from the type constructor by making it polymorphic as well. In order to get a new type two type parameters are required - a type constructor and a type. We can apply `T<A>` to any type constructor that expects at least one type parameter, not only to a linked list. We generalized the type constructor to make it applicable to a wider range of data structures.

### Parametric polymorphism

Parametric polymorphism is a powerful but also somewhat limited form of polymorphism. The basic idea is that a function or value constructor must not know anything about its parametric polymorphic parameters, that is, they can be of any type. The only fully parametric polymorphic function is identity `<A>(x: A): A => x`. The concept is far more useful along with higher order functions and allows elegant and concise types:

```javascript
const arrMap = <A, B>(f: (x: A) => B) => (xs: A[]): B[] => xs.map(f);
```
### Ad-hoc polymorphism

Ad-hoc polymorphism is 

### Subtype polymorphism

### Row polymorphism

### Structural versus nominal typing

### Type classes

We are almost finished with type theory. If you look at `id`'s type `<A>(x: A) => A` you can see that it has a generic type parameter. As a result `id` must not know anything about the value of the corresponding argument, because it can be any value of any type. This applies to all functions that accept generic type parameters. Any function that takes one or more generic type parameters are parametric polymorphic in these arguments.

