## A Little Type Theory

### Values and types

Every programming language has values and every value has a type. In type theory lingo this is expressed as types are inhabited by values. Please note that I will use Typescript notation to denote types:

```javascript
undefined // undefined

null // null

true // boolean

123 // number

[1, 2, 3] // number[]

new Set(["abc"]) // Set<string>

{foo: [1, 2, 3]} // {foo: number[]}

const map = f => xs => xs.map(f); // omitting the type for now
const len = xs => xs.length; // omitting the type for now

map(len) (["b", "ba", "bar"]) // <string, number>(f: (x: string) => number) => (xs: string[]) => number[]
```
A type can be inhabited by either no value at all (`undefined`), one value (`null`) or any number of values. Since `undefined` indicates a type error in Javascript, we pretend the corresponding type has no value.

### Value and type constructors

A value constructor takes no or more values and returns a new value:

```javascript
// built-ins

null // null

Boolean // <A>(arg: A) => boolean

Array // <A>(...args: A[]) => A[]

Set // <A>(arg: Iterable<A>) => Set<A>

// custom

const Foo = xs => ({foo: xs});

Foo // <A>(xs: A[]) => {foo: A[]}

class Pair<A, B> extends Array {
  constructor(x: A, y: B) {
    const r: [A, B] = super(2);
    r[0] = x;
    r[1] = y;
    return r;
  }
}

Pair // Pair<A, B>(x: A, y: B) => Pair<A, B>
```

A type constructor is like a function on the type level: It needs at least one type to become a type itself:

```javascript
x => {foo: x}; // <A>(x: A) => {foo: A}

xs => new Set(xs); // <A>(xs: A[]) => Set<A>

x => x; // <A>(x: A) => A

true; // boolean

null; // null
```
In the first example `x => {foo: x}` is the value and `<A>(x: A) => {foo: A}` the type constructor. Both are unary, i.e. expect one argument. booleans are declared as a nullary type constructor `boolean` and two associated nullary value constructors `true` and `false`. A nullary type consturctor is just a type. A nullary value constructor is just a constant. While the `boolean` type is inhabited by two values (`true`/`false`), `null` is only inhabited by a single value `null`. As you can see the value and type constructor are indistinguishable in this case.

### Type classes

We are almost finished with type theory. If you look at `id`'s type `<A>(x: A) => A` you can see that it has a generic type parameter. As a result `id` must not know anything about the value of the corresponding argument, because it can be any value of any type. This applies to all functions that accept generic type parameters. Any function that takes one or more generic type parameters are parametric polymorphic in these arguments.

Parametric polymorphism is rather uncompromising form of polymorphism. Sometimes a function just needs to know a cetain aspect of a type. With just parametric polymorphism, we would have to fall back to monomorphic types like `number` or `number[]`. Luckily type classes can chime in. Type classes describe a particular aspect of a type. A function that takes a type class accepts any type that implements it, i.e. has an instance of this type class. This form of polymorphism is called ad-hoc polymorphism.
