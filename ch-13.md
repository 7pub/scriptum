## Lifting Pure Functions with Functors

A functor is a rather simple concept. The characteristic that renders it so elusive is its generality. Numerous very different data types can implement it.

### Definition

A functor in the context of functional programming is an algebraic structure that has the following traits:

* it is an unary higher-order type constructor
* it is associated with a binary operation called map
* map must abide by the functor laws

This enumeration is not particularly helpful. Let us dig deeper.

### Algebraic structures

A functor is an algebraic structure, i.e. it comes from math. An algebraic structure consists of

* a set of entities
* one or more operations
* one or more axioms

Translated to the programming world an algebraic structure has

* instances for various types
* one or more associated functions or values under unique names
* one or more laws associated functions must abide by

### Term level

The actual programming with value constructors, functions, expressions and values takes place at the term level. It is complemented by the type level, where type constructors (paramterized types) and proper types exist.

First we will explore what constitutes a functor at the term level.

#### Map operation

Every functor has an associated `map` operation, wich is a binary function:

```javascript
const map = f => tx => ???
```

But what does it exactly do? At the beginning of this chapter I mentioned that functors are so hard to grasp because they are so general. Consequently `map`'s operation is hard to describe in natural language without falling back to fuzzy metaphors. I will give it a shot in the following two sections.

#### Lift pure functions into a context

A functor lifts - there it is, the mentioned metaphor - an ordinary pure function into a context. Let us pretend within this section that a context is a container-like data structure, an `Array` for example. So a functor lifts an ordinary pure function into a container-like data structure:

```javascript
// binary map operation
const map = f => xs =>
  xs.map(x => f(x));
  
// a pure function
const inc = n => n + 1;
  
map(inc) ([1, 2, 3]); // [2, 3, 4]
```
By supplying a `map` operation for each data type that implements functor, we can reuse pure functions for all container-like data structures. This is an enormous win in terms of code reuse.

However, functors do not stop at containers. They start with them.

#### What is a context?

A context can be almost everything, for example

* a data structure
* a priorized choice
* a computation that may fail
* a computation with a read-only environment
* a computation with a write-only environment
* a stateful computation
* an asynchronous computation
* a lazy evaluated computation
* a computation that refies the rest of the application

There are many more. The fact that you can apply functors to so many contexts and their corresponding types is what renders the concept so general and thus hard to grasp. We will examine each of the listed contexts or rather their types in later chapters of this course.

Functors enable us to reuse ordinary pure functions in numerous different contexts. As I have already mentioned this facilitates code reuse tremendously. Functors are ubiquitous in functional code and since the underlying mechanism is always the same, the code gets highly predictable.

We can roughly divide functor contexts into two major categories:

* contexts forming a structure
* contexts causing an effect

The structure context is obvious and is generally associated with functors. However, effects form the more numerous category. Looking at effects we can think of functors as a concept that allows us to abstract from effects by encoding them as values. These values can then be applied to ordinary pure functions, while the effects are automatically taken care of.

#### Functor laws

I am going to use the array type again to illustrate the functor laws. The first functor law states:

```javascript
const map = f => xs =>
  xs.map(x => f(x));
  
const id = x => x;

map(id) ([1, 2, 3]).toString() ===
  id([1, 2, 3]).toString(); // true
```
It determines that a functor must only transform values, whereas the context must remain untouched. The second functor law states:

```javascript
const map = f => xs =>
  xs.map(x => f(x));

const id = x => x;

const comp = f => g => x =>
  f(g(x));

map(comp(id) (id)) ([1, 2, 3]).toString() ===
  comp(map(id)) (map(id)) ([1, 2, 3]).toString()
```
This determines that the `map` operation must be associative.

#### Context preserving

From the first functor law we can derive that functors have to be context preserving. A functor must transform the values in a context but must not touch the context itself:

```javascript
[1, 2, 3] -- context preserving transformation --> [1, 4, 9]
[1, 2, 3] -- context preserving transformation --> [[1, 1], [2, 2], [3, 3]]

[1, 2, 3] -- invlaid transformation --> [1, 2, 3, 4]
[1, 2, 3] -- invalid transformation --> [3, 2, 1]
```
### Type level

At the type level a functor is a higher-order type constructor parameterized with a single type:

```javascript
type Array<A>; // first-order type constructor (array type)
type F<A>; // higher-order type constructor (functor type)
```
`F<A>` represents the functor at the type level. `F` is the context and `A` the value part. Abstracting from the type constructor is necessary, because a functor can be defined for various contexts, not only for arrays.

### Context once again

We are still lacking an accurate definition of the functorial context without resorting to fuzzy metaphors. As programmers it is obvious to define an abstract concept precisely using functions. For each context there should be one or more associated functions which leave the values untouched and consequently only operate on the contextual part. This collection of functions define what a context actually is:

```javascript
const len = xs => xs.length;

const head = def => xs =>
  xs.length === 0
    ? def
    : xs[0];

const reverse = xs => xs.reverse();
```
`len`, `head`, `reverse` et al. describe different aspects of the array context. But they do more than just describing. If we follow this idea we can even claim that they constitute this very context.

Last but not least it is noteworthy that a type may have more than one meaningful context and thus may have several functor declarations.

### Functor type class through dictionary passing style (DPS)

Typescript does not natively support Haskell-style implicit type classes, but simple name overloading. While there is a way to imitate the former, it leads to rather entangled and complex type definitions. For the sake of simplicity I decided to fall back to dictionary passing style, which can be considered the poor man's type classes.

DPS basically means that every ad-hoc polymorphic functon must define its first formal parameter as a type dictionary. In our case a type dictionary is just a plain old Javascript object containing the overloaded type class operations. This way we are freed from a specific argument order these operations have to be passed to the polymorphic function, provided a type class has more than a single operation at all:

```javascript
foo({f, g, x}) (arg1) (arg2);
//  ^^^^^^^^^ type dictionary     

bar(f) (arg1) (arg2);
//  ^ exception for single operation constraints
```
So for type classes with only a single operation we can exceptionally pass the bare function argument.

Now that we have settled on the encoding of type dictionaries and how to apply them to functions let us declare a real world ad-hoc polymorphic function using dictionary passing style:

```javascript
const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));

const funMap = f => g =>
  x => f(g(x));

const mapEff = map => x =>
//             ^^^ overloaded function constraint
  map(_ => x);
  
const sqr = x => x * x;
  
mapEff(arrMap) (5) ([1, 2, 3]); // [5, 5, 5]
//     ^^^^^^ single function instead of type dictionary

mapEff(funMap) (5) (sqr); // y => (_ => x) (sqr(y))
//     ^^^^^^ single function instead of type dictionary
```
With `mapEff` we are only interested in the structure or effect of a computation rather than its result value. It works for all types that have an instance of functor, namely an implementation of the `map` function. Since `mapEff` only expects a single overloaded name we pass the argument as a bare function instead of a function wrapped in a type dictionary.

Here is a more complex example with several overloaded functions involved, which unvortunately does not involve the functor type class. I will replace this with an implementation including a functorial constraint as soon as I get eyes on an appropriate example:

```javascript
// ad-hoc polymorphic function

const foldMap = ({fold, append, empty}) => f =>
//               ^^^^^^^^^^^^^^^^^^^^^ overloaded function constraints
  fold(comp2nd(append) (f)) (empty.fresh);

// array instances

const arrFold = f => acc => xs => {
  for (let i = 0; i < xs.length; i++)
    acc = f(acc) (xs[i], i);

  return acc;
};

// number instances

const add = x => y => x + y;

const addEmpty =
  {get fresh() {return 0}};

// auxiliary functions

const comp2nd = f => g => x => y =>
  f(x) (g(y));
  
const sqr = x => x * x;
  
// MAIN

const xs = [1, 2, 3];

foldMap({fold: arrFold, append: add, empty: addEmpty})
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type dictionary
  (sqr)
    (xs); // 14
```
[run code](https://repl.it/repls/HighlevelOblongDatamart)

### Functors are composable

This was a lot of theory. Let us implement a couple of functors and compose them, because functors do compose by design. I am going to show how this pure increment function `x => x + 1` is applied to an array structure, which may or may not be produced as the result of an asynchronous computation:

```javascript
/***[ Task ]******************************************************************/

const Task = task => record(
  Task,
  thisify(o => {
    o.task = (res, rej) =>
      task(x => {
        o.task = k_ => k_(x);
        return res(x);
      }, rej);
    
    return o;
  }));

// functor

const tMap = f => tx =>
  Task((res, rej) => tx.task(x => res(f(x)), rej));

const delay = f => ms => x =>
  Task((res, rej) => setTimeout(x => res(f(x)), ms, x));

/***[ Option ]****************************************************************/

const Option = union("Option");

const None = Option("None", {});

const Some = some => Option(Some, {some});

// functor

const optMap = f => tx =>
  match(tx, {
    None: _ => None,
    Some: ({some: x}) => Some(f(x))
  });

/***[ Array ]*****************************************************************/

// functor

const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));

/***[ Main ]******************************************************************/

// the above code is usualy abstracted away in a functional library like scriptum

const asyncFetch1 = delay(_ => Some([1, 2, 3])) (1000) ();
//                                  ^^^^^^^^^ original array
const asyncFetch2 = delay(_ => None) (1500) ();
//                             ^^^^ no array at all

const main1 = tMap(optMap(arrMap(inc))) (asyncFetch1);
const main2 = tMap(optMap(arrMap(inc))) (asyncFetch2);

// run the asynchronous computation

main1.task(log); // {some: [2, 3, 4 ], Option: "Option", tag: "Some"}
main2.task(log); // {Option: "Option", tag: "None"}
```
[run code](https://repl.it/repls/EnormousCooperativeFormula)

All it takes to lift the pure `inc` function into an asynchronous context that either contains an array of natural numbers or nothing at all is `tMap(optMap(arrMap(inc)))`, that is, pure functor composition. The crucial part is that not only lift `inc` but any possible pure function can be lifted in any functor. As soon as the functor interface is extended by applicative we can even lift binary or higher n-ary functions into a functorial context. We will learn how to achieve this in a later chapter of this course.

[&lt; prev chapter](https://github.com/kongware/scriptum/blob/master/ch-12.md) | [TOC](https://github.com/kongware/scriptum#functional-programming-course-toc)
