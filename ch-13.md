## Lifting Pure Functions with Functors

A functor is a rather simple concept. The characteristic that renders it so elusive is its generality. Numerous very different data types can implement it.

### Definition

A functor in the context of functional programming is an algebraic structure that has the following traits:

* it is an unary higher-order type constructor
* it is associated with a binary operation called map
* map must abide by the functor laws

This enumeration is not particularly helpful. Let us dig deeper.

### Algebraic structures

A functor is an algebraic structure, i.e. it comes from math. An algebraic structure consists of

* a set of entities
* one or more operations
* one or more axioms

Translated to the programming world an algebraic structure

* is implemented as a type class
* has one or more associated functions or values under unique names
* has one or more laws associated functions must abide by

### Term level

The actual programming with value constructors, functions, expressions and values takes place at the term level. It is complemented by the type level, where type constructors (paramterized types) and proper types exist.

First we will explore what constitutes a functor on the term level.

#### Map operation

Every functor has an associated `map` operation, wich is a binary function:

```javascript
const map = f => tx => ???
```

But what does it exactly do? At the beginning of this chapter I mentioned that functors are so hard to grasp because they are so general. Consequently `map`'s operation is hard to describe in natural language without falling back to fuzzy metaphors. I will give it a shot in the following two sections.

#### Lift pure functions into a context

A functor lifts - there it is, the metaphor - an ordinary pure function into a context. Let us pretend within this section that a context is a container-like data structure, an `Array` for example. So a functor lifts an ordinary pure function into an container-like data structure:

```javascript
// binary map operation
const map = f => xs =>
  xs.map(x => f(x));
  
// a pure function
const inc = n => n + 1;
  
map(inc) ([1, 2, 3]); // [2, 3, 4]
```
By supplying an overloaded `map` operation, we can reuse pure functions for all container-like data structures. This is an enormous win in terms of code reuse.

However, this is merely a very simplified description of a functor. The concept does not stop at containers. It begins with them.

#### What is a context?

A context can be almost everything, for example

* a structure
* a priorized choice
* a computation that may fail
* a computation with a shared read-only environment
* a computation with a shared write-only environment
* a stateful computation
* an asynchronous computation
* a lazy evaluated computation
* a computation that refies the rest of the program

There are many more. The fact that you can apply functors to so many contexts and their corresponding types is what renders the concept so general and thus hard to grasp. We will examine each of the listed contexts in later chapters of this course.

Functors enable us to reuse ordinary pure functions in numerous different contexts. As I have already mentioned this facilitates code reuse tremendously. Functors are ubiquitous in functional code and since the underlying mechanism is always the same, the code is highly predictable.

We can roughly divide functor contexts into two major categories:

* contexts forming a structure
* contexts forming an effect

The structure context is obvious and is in general associated with functors. Effects, however, are the even more extensive category. We can think of functors as a concept that allows us to encode effects as values and reuse our ordinary pure functions to operate on these effectful values.

#### Functor laws

I am going to use the array type again to illustrate the functor laws. The first functor law defines:

```javascript
const map = f => xs =>
  xs.map(x => f(x));
  
const id = x => x;

map(id) ([1, 2, 3]).toString() ===
  id([1, 2, 3]).toString(); // true
```
This determines that a functor must only transform values, whereas it must leave the context untouched. The second functor law defines:

```javascript
const map = f => xs =>
  xs.map(x => f(x));

const id = x => x;

const comp = f => g => x =>
  f(g(x));

map(comp(id) (id)) ([1, 2, 3]).toString() ===
  comp(map(id)) (map(id)) ([1, 2, 3]).toString()
```
This determines that the `map` operation must be associative.

#### Context preserving

We can derive from the first functor law that functors have to be context preserving. A functor must transform the values in a context but must not touch the context itself:

```javascript
[1, 2, 3] -- context preserving transformation --> [1, 4, 9]
[1, 2, 3] -- context preserving transformation --> [[1, 1], [2, 2], [3, 3]]

[1, 2, 3] -- invlaid transformation --> [1, 2, 3, 4]
[1, 2, 3] -- invalid transformation --> [3, 2, 1]
```
### Type level

At the type level a functor is a higher-order type constructor parameterized with a single type:

```javascript
type Array<A>; // first-order type constructor (array type)
type F<A>; // higher-order type constructor (functor type)
```
`F<A>` represents the functor on the type level. `F` is the context and `A` the value part. Abstracting from the type constructor is necessary, because a functor can be defined for various contexts, not only for arrays.

### Context once again

We are still lacking an accurate definition of the functor context without resorting to fuzzy metaphors. As programmers it is natural to define something abstract only using functions. For each context there should be at least one or even more associated functions that do not touch any values and consequently exclusively operate on the context. From a programming perspective this collection of functions defines a context adequately. Let us illustrate this thought using the array context:

```javascript
const len = xs => xs.length;

const head = def => xs =>
  xs.length === 0
    ? def
    : xs[0];

const reverse = xs => xs.reverse();
```
It is noteworthy that a type may have more than one meaningful context and thus may have several functor declarations.

### Functor type class through dictionary passing style (DPS)

Typescript does support name overloading but no type classes. While there is a way to imitate the latter it leads to entangled and complex type definitions. Therefore I decided to resort to dictionary passing style, which basically means explicit type classes on the term level.

DPS simply means to encode type classes as dictionaries and pass them to functions in order to generalize them utilizing ad-hoc polymorphism. We will use plain old Javascript objects to encode type classes, which frees us from a specific order of arguments:

```javascript
foo({fun1, fun2, val1, val2}) (arg1) (arg2);
//  ^^^^^^^^^^^^^^^^^^^^^^^^ type dictionary     

bar(fun1) (arg1) (arg2);
//  ^^^^ exception for single-element constraints
```

We can use a bare function or value instead of a type dictionary, provided the ad-hoc polymorphic function only requires a single overloaded name.

### Functors are composable

This was a lot of theory. Let us implement a couple of functors and compose them, because they do compose by design. I will show how this pure increment function `x => x + 1` will be applied to an array structure, which may be yielded as the result of an asynchronous computation, provided there is a result at all:

```javascript
/***[ Misc. ]*****************************************************************/

const record = (type, o) =>
  (o[type.name || type] = type.name || type, o);

const union = type => (tag, o) =>
  (o[type] = type, o.tag = tag.name || tag, o);

const match = (tx, o) =>
  o[tx.tag] (tx);

/***[ Task ]******************************************************************/

const Task = task => record(
  Task,
  thisify(o => {
    o.task = (res, rej) =>
      task(x => {
        o.task = k_ => k_(x);
        return res(x);
      }, rej);
    
    return o;
  }));

// functor

const tMap = f => tx =>
  Task((res, rej) => tx.task(x => res(f(x)), rej));

const delay = f => ms => x =>
  Task((res, rej) => setTimeout(x => res(f(x)), ms, x));

/***[ Option ]****************************************************************/

const Option = union("Option");

const None = Option("None", {});

const Some = some => Option(Some, {some});

// functor

const optMap = f => tx =>
  match(tx, {
    None: _ => None,
    Some: ({some: x}) => Some(f(x))
  });

/***[ Array ]*****************************************************************/

// functor

const arrMap = f => xs =>
  xs.map((x, i) => f(x, i));

/***[ Auxiliary ]*************************************************************/
  
const thisify = f => f({});

const log = x => (console.log(x), x);

const inc = x => x + 1;

/***[ Main ]******************************************************************/

// the above code is usualy abstracted away in a functional library like scriptum

const asyncFetch1 = delay(_ => Some([1, 2, 3])) (1000) ();
//                                  ^^^^^^^^^ original array
const asyncFetch2 = delay(_ => None) (1500) ();
//                             ^^^^ no array at all

const main1 = tMap(optMap(arrMap(inc))) (asyncFetch1);
const main2 = tMap(optMap(arrMap(inc))) (asyncFetch2);

// run the asynchronous computation

main1.task(log); // {some: [2, 3, 4 ], Option: "Option", tag: "Some"}
main2.task(log); // {Option: "Option", tag: "None"}
```
[run code](https://repl.it/repls/EnormousCooperativeFormula)

All it takes to lift the pure `inc` function into an asynchronous context that either contains an array of natural numbers or nothing at all is `tMap(optMap(arrMap(inc)))`, that is, functor composition. We can not only lift `inc` in any functor, but any possible pure function. When functor is enhanced by applicative we can even lift binary and other n-ary functions into the context of a functor. We will learn how to accomplish that in a later chapter of this course.

[&lt; prev chapter](https://github.com/kongware/scriptum/blob/master/ch-12.md) | [TOC](https://github.com/kongware/scriptum#functional-programming-course-toc)
